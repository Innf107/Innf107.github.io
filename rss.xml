<rss version="2.0">
    <channel>
        <title>Prophetlabs</title>
        <description>My Blog</description>
        <link>https://prophetlabs.de</link>
        <pubDate>05-05-2022</pubDate>
        <lastBuildDate>05-05-2022</lastBuildDate>
        <ttl>60</ttl>
        <item>
    <title> Coherent Local Instances with Dynamic Types and ImplicitParams</title>
    <link>https://prophetlabs.de/posts/coherentIP.html</link>
    <guid isPremaLink="true">https://prophetlabs.de/posts/coherentIP.html</guid>
    <pubDate>2022-8-29</pubDate>
    <description>



&lt;p&gt;If you read my &lt;a href="/posts/unsafeCoerceDict.html"&gt;previous
post&lt;/a&gt;&lt;a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt; about local instances, you might
have noticed something. Remember how I said that
&lt;code&gt;ImplicitParams&lt;/code&gt; are really just &lt;a
href="/posts/unsafeCoerceDict.html#implicitparams"&gt;syntactic sugar for
instances of the type class &lt;code&gt;GHC.Classes.IP&lt;/code&gt;&lt;/a&gt;? Well,
unlike &lt;code&gt;withFakeDict&lt;/code&gt;, &lt;code&gt;ImplicitParams&lt;/code&gt; can safely
be overridden, without causing incoherence issues. Couldn’t we somehow
use &lt;code&gt;ImplicitParams&lt;/code&gt; to provide local type class instances
that can safely be overridden?&lt;/p&gt;
&lt;p&gt;Most type classes are a bit more complex than they look, so let’s
invent a new one to use as a running example.&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    pretty ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Pretty&lt;/code&gt; is just like &lt;code&gt;Show&lt;/code&gt;, but with fewer
methods and no preexisting instances that might get in our way.&lt;/p&gt;
&lt;p&gt;We also need to define a dictionary type for &lt;code&gt;Pretty&lt;/code&gt;. We
could use the Template Haskell machinery from last time for this, but
&lt;code&gt;Pretty&lt;/code&gt; is simple enough to do it manually for now.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- The newtype is important since `Pretty` only has a single method&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    _pretty ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;}&lt;/span&gt;
&lt;span id="cb2-5"&gt;&lt;a href="#cb2-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-6"&gt;&lt;a href="#cb2-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;boringPretty ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-7"&gt;&lt;a href="#cb2-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;boringPretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb2-8"&gt;&lt;a href="#cb2-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _pretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-9"&gt;&lt;a href="#cb2-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;}&lt;/span&gt;
&lt;span id="cb2-10"&gt;&lt;a href="#cb2-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb2-11"&gt;&lt;a href="#cb2-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;nicePretty ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-12"&gt;&lt;a href="#cb2-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;nicePretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb2-13"&gt;&lt;a href="#cb2-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _pretty &lt;span class="ot"&gt;=&lt;/span&gt; \x &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;✨&quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; x &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;✨&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-14"&gt;&lt;a href="#cb2-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With this, we could already write a few functions that use our ‘type
class’, just by accepting a corresponding dictionary as an implicit
parameter. This way we actually get something closely resembling local
instances already!&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; (&lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt; _pretty &lt;span class="op"&gt;?&lt;/span&gt;prettyInst&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; [a] &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f xs &lt;span class="ot"&gt;=&lt;/span&gt; intercalate &lt;span class="st"&gt;&quot;, &quot;&lt;/span&gt; (&lt;span class="fu"&gt;map&lt;/span&gt; pretty xs)&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; boringPretty&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; f [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; nicePretty &lt;span class="kw"&gt;in&lt;/span&gt; &lt;span class="fu"&gt;putStrLn&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; f [&lt;span class="dv"&gt;1&lt;/span&gt;, &lt;span class="dv"&gt;2&lt;/span&gt;, &lt;span class="dv"&gt;3&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;]&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Let’s also enable optimizations, just to make sure this is actually
coherent. :)&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre
class="sourceCode txt"&gt;&lt;code class="sourceCode default"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;$ ghc -O2 Main.hs &amp;&amp; ./Main&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;[1 of 1] Compiling Main             ( Main.hs, Main.o )&lt;/span&gt;
&lt;span id="cb4-3"&gt;&lt;a href="#cb4-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;Linking Main ...&lt;/span&gt;
&lt;span id="cb4-4"&gt;&lt;a href="#cb4-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;5&lt;/span&gt;
&lt;span id="cb4-5"&gt;&lt;a href="#cb4-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;✨5✨&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect!&lt;/p&gt;
&lt;p&gt;There is just one issue. While &lt;code&gt;ImplicitParams&lt;/code&gt; make it
almost trivial to work with &lt;em&gt;local&lt;/em&gt; instances, we lose the
ability to define regular &lt;em&gt;global&lt;/em&gt; instances.&lt;/p&gt;
&lt;p&gt;Whenever we want to use a function with a &lt;code&gt;?prettyInst&lt;/code&gt;
constraint, we always have to define the instance we want to use
somewhere locally in its lexical scope.&lt;/p&gt;
&lt;p&gt;If we wanted an actual replacement for type classes with local
&lt;em&gt;and&lt;/em&gt; global instances, we would need some kind of…&lt;/p&gt;
&lt;h2 id="global-implicitparams"&gt;Global &lt;code&gt;ImplicitParams&lt;/code&gt;?&lt;/h2&gt;
&lt;p&gt;Remember how &lt;code&gt;IP&lt;/code&gt; is just a regular type class? Couldn’t
we just… you know… define a regular, global instance for
&lt;code&gt;IP&lt;/code&gt;?&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-2"&gt;&lt;a href="#cb5-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ip &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-3"&gt;&lt;a href="#cb5-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-4"&gt;&lt;a href="#cb5-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;x&lt;/span&gt;
&lt;span id="cb5-5"&gt;&lt;a href="#cb5-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So… uh… I honestly did not expect this to work, considering GHC
forbids manual &lt;code&gt;Typeable&lt;/code&gt; or &lt;code&gt;Generic&lt;/code&gt;
instances.&lt;/p&gt;
&lt;p&gt;Anyway, if we want to model our class with this, we can simply write
global instances as instances for &lt;code&gt;IP&lt;/code&gt; and override local
instances with &lt;code&gt;let ?x = ...&lt;/code&gt; just as we did before.&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb6-1"&gt;&lt;a href="#cb6-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;prettyInst&quot;&lt;/span&gt; (&lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-2"&gt;&lt;a href="#cb6-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    pretty &lt;span class="ot"&gt;=&lt;/span&gt; boringPretty&lt;/span&gt;
&lt;span id="cb6-3"&gt;&lt;a href="#cb6-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb6-4"&gt;&lt;a href="#cb6-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb6-5"&gt;&lt;a href="#cb6-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb6-6"&gt;&lt;a href="#cb6-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (pretty (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb6-7"&gt;&lt;a href="#cb6-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (&lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; nicePretty &lt;span class="kw"&gt;in&lt;/span&gt; pretty (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre
class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb7-1"&gt;&lt;a href="#cb7-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc &lt;span class="at"&gt;-O2&lt;/span&gt; Main.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./Main&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-2"&gt;&lt;a href="#cb7-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;Main.hs,&lt;/span&gt; Main.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-3"&gt;&lt;a href="#cb7-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; Main ...&lt;/span&gt;
&lt;span id="cb7-4"&gt;&lt;a href="#cb7-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-5"&gt;&lt;a href="#cb7-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;✨5✨&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Awesome! Unlike our unsafeCoerce trick last time, optimizations don’t
break &lt;code&gt;ImplicitParams&lt;/code&gt;, so this is entirely safe!&lt;/p&gt;
&lt;p&gt;We just came up with a type class replacement that completely
subsumes local, as well as global instances in a few lines of code.&lt;/p&gt;
&lt;p&gt;It’s that simple!&lt;/p&gt;
&lt;h2 id="its-not-that-simple"&gt;It’s not that simple&lt;/h2&gt;
&lt;p&gt;If you look at the definition of &lt;code&gt;IP&lt;/code&gt;, you will likely
notice the deadly flaw in our current approach&lt;/p&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb8-1"&gt;&lt;a href="#cb8-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; x a &lt;span class="op"&gt;|&lt;/span&gt; x &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-2"&gt;&lt;a href="#cb8-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    ip ::&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;strong&gt;There is a functional dependency between the parameter name
and its type.&lt;/strong&gt;&lt;a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt; This means that every parameter name
can only ever be used with &lt;em&gt;the same type argument&lt;/em&gt; and so our
type class replacement can only ever have a single instance per class.
The entire purpose of type classes is to overload operations for
different types, so this completely defeats the point of using type
classes in the first place. :/&lt;/p&gt;
&lt;p&gt;If we try to write an instance for two separate types anyway, the
compiler is going to complain as expected, since we violated the
functional dependency.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;prettyInst&quot;&lt;/span&gt; (&lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    pretty &lt;span class="ot"&gt;=&lt;/span&gt; boringPretty&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- Error: Functional dependency conflict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-5"&gt;&lt;a href="#cb9-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;prettyInst&quot;&lt;/span&gt; (&lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-6"&gt;&lt;a href="#cb9-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    pretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="fu"&gt;id&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2
id="when-life-gives-you-lemons"&gt;&lt;a href="https://www.youtube.com/watch?v=g8ufRnf2Exc" target="_blank"&gt;When
life gives you lemons&lt;/a&gt;&lt;/h2&gt;
&lt;p&gt;Unfortunately, since we can only have a single global &lt;code&gt;IP&lt;/code&gt;
instance, we cannot use Haskell’s regular type class dispatching
mechanism to select the instance that we want.&lt;/p&gt;
&lt;p&gt;But…&lt;/p&gt;
&lt;p&gt;we could try and build our own, &lt;em&gt;based on runtime type
information&lt;/em&gt;. This solution will not work for all types, but it
might work for all that implement &lt;code&gt;Typeable&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With &lt;code&gt;Typeable&lt;/code&gt;, we can extract a &lt;code&gt;TypeRep&lt;/code&gt;&lt;a
href="#fn3" class="footnote-ref" id="fnref3"
role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; from a &lt;code&gt;Proxy&lt;/code&gt; for a
given type and, thanks to &lt;code&gt;typeRepFingerprint&lt;/code&gt;, we are able
to turn this &lt;code&gt;TypeRep&lt;/code&gt; into a &lt;code&gt;Fingerprint&lt;/code&gt; that
is unique for every type. This &lt;code&gt;Fingerprint&lt;/code&gt; implements
&lt;code&gt;Ord&lt;/code&gt;, so we can use it as a key in a &lt;code&gt;Map&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;With this, we can build some machinery that selects an instance from
a &lt;code&gt;Map&lt;/code&gt; based on the runtime &lt;code&gt;TypeRep&lt;/code&gt; of a type.
The values of the &lt;code&gt;Map&lt;/code&gt; then represent the instances for the
given types.&lt;/p&gt;
&lt;p&gt;Conveniently, we already have a way of reifying instances, so we can
just store the concrete dictionaries (&lt;code&gt;PrettyDict&lt;/code&gt;s in this
case).&lt;/p&gt;
&lt;p&gt;We have to store dictionaries of different types
(e.g. &lt;code&gt;PrettyDict Int&lt;/code&gt;, &lt;code&gt;PrettyDict Bool&lt;/code&gt;, …), so
we could try some tricks with existentials, but since we are relying on
runtime type information anyway, it is easier to store them as &lt;a
href="https://hackage.haskell.org/package/base-4.16.1.0/docs/GHC-Exts.html#t:Any"&gt;&lt;code&gt;Any&lt;/code&gt;&lt;/a&gt;
and use &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; {&lt;span class="ot"&gt;unInstMap ::&lt;/span&gt; &lt;span class="dt"&gt;Map&lt;/span&gt; &lt;span class="dt"&gt;Fingerprint&lt;/span&gt; &lt;span class="dt"&gt;Any&lt;/span&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To actually use this custom dispatching mechanism, we need to
reimplement our &lt;code&gt;pretty&lt;/code&gt; ‘method’, which now takes an
&lt;code&gt;InstMap&lt;/code&gt; as an implicit parameter and extracts the
dictionary for the type used, based on its &lt;code&gt;TypeRep&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb11-1"&gt;&lt;a href="#cb11-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-2"&gt;&lt;a href="#cb11-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-3"&gt;&lt;a href="#cb11-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-4"&gt;&lt;a href="#cb11-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; M.lookup key (unInstMap &lt;span class="op"&gt;?&lt;/span&gt;prettyInst) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-5"&gt;&lt;a href="#cb11-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&quot;pretty: No instance found at runtime&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb11-6"&gt;&lt;a href="#cb11-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; dict &lt;span class="ot"&gt;-&gt;&lt;/span&gt; _pretty &lt;span class="op"&gt;$&lt;/span&gt; unsafeCoerce dict&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To add a local instance to the instance map, all we have to do is to
update the implicit &lt;code&gt;?prettyInst&lt;/code&gt; parameter.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb12-1"&gt;&lt;a href="#cb12-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withPretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a b&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; ((&lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id="cb12-2"&gt;&lt;a href="#cb12-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withPretty dict x &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-3"&gt;&lt;a href="#cb12-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-4"&gt;&lt;a href="#cb12-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; prevInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-5"&gt;&lt;a href="#cb12-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; (M.insert key (unsafeCoerce dict) prevInst) &lt;span class="kw"&gt;in&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb12-6"&gt;&lt;a href="#cb12-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Okay, so we gave up type safety, but in return, we gained the ability
to override instances locally… which we could already do with just
&lt;code&gt;ImplicitParams&lt;/code&gt; without any runtime type dispatch machinery.
Sounds like we are back to square one?&lt;/p&gt;
&lt;h2 id="recovering-type-safety"&gt;Recovering type safety&lt;/h2&gt;
&lt;p&gt;We have a way of locally overriding instances, but we should really
make sure that instances are actually available.&lt;/p&gt;
&lt;p&gt;How could we check this? Well, type classes are perfect for
invariants like this!&lt;/p&gt;
&lt;p&gt;If using type classes to implement a type class replacement sounds
pointless, keep in mind that we don’t care about the type class methods.
In fact, we don’t even need any! This way, incoherence is not an issue,
since the concrete instance chosen is irrelevant.&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb13-1"&gt;&lt;a href="#cb13-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb13-2"&gt;&lt;a href="#cb13-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb13-3"&gt;&lt;a href="#cb13-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-4"&gt;&lt;a href="#cb13-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="co"&gt;-- same implementation&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we didn’t change anything on the term level. The
&lt;code&gt;HasPretty&lt;/code&gt; constraint in the type purely exists to make sure
that we call &lt;code&gt;withPretty&lt;/code&gt; at some point before calling
&lt;code&gt;pretty&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;To satisfy the &lt;code&gt;HasPretty&lt;/code&gt; constraint in the continuation
passed to &lt;code&gt;withPretty&lt;/code&gt;, we can just use the
&lt;code&gt;unsafeCoerce&lt;/code&gt; trick from the previous post.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb14-1"&gt;&lt;a href="#cb14-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-2"&gt;&lt;a href="#cb14-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb14-3"&gt;&lt;a href="#cb14-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-4"&gt;&lt;a href="#cb14-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb14-5"&gt;&lt;a href="#cb14-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withPretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a b&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt; a &lt;/span&gt;
&lt;span id="cb14-6"&gt;&lt;a href="#cb14-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;           &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;/span&gt;
&lt;span id="cb14-7"&gt;&lt;a href="#cb14-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;           &lt;span class="ot"&gt;-&gt;&lt;/span&gt; ((&lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; b) &lt;/span&gt;
&lt;span id="cb14-8"&gt;&lt;a href="#cb14-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;           &lt;span class="ot"&gt;-&gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id="cb14-9"&gt;&lt;a href="#cb14-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withPretty dict x &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-10"&gt;&lt;a href="#cb14-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-11"&gt;&lt;a href="#cb14-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; previousInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-12"&gt;&lt;a href="#cb14-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; unsafeCoerce (&lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;))&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;HasPretty&lt;/span&gt; a) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-13"&gt;&lt;a href="#cb14-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb14-14"&gt;&lt;a href="#cb14-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; (M.insert key (unsafeCoerce dict) previousInst) &lt;span class="kw"&gt;in&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb14-15"&gt;&lt;a href="#cb14-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So, a function that would have a &lt;code&gt;Pretty a&lt;/code&gt; constraint
with regular classes or a &lt;code&gt;(?prettyInst :: PrettyDict a)&lt;/code&gt;
constraint with &lt;code&gt;ImplicitParams&lt;/code&gt;, now needs a
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;
constraint.&lt;/p&gt;
&lt;h2 id="going-global"&gt;Going global&lt;/h2&gt;
&lt;p&gt;We recovered type safety, but our approach still doesn’t offer any
advantage over pure &lt;code&gt;ImplicitParams&lt;/code&gt;, since we still don’t
have a way to write global instances.&lt;/p&gt;
&lt;p&gt;Your first thought might be to write a global instance for
&lt;code&gt;IP "prettyInst" InstMap&lt;/code&gt; and somehow populate that when
defining new global instances.&lt;/p&gt;
&lt;p&gt;Unfortunately, this doesn’t work. We could try to use a global
&lt;code&gt;IORef&lt;/code&gt; and extend it at runtime, but how would we run the
code to extend that IORef? Haskell doesn’t provide a way to run IO code
at module load time, so we couldn’t make sure that the map contains all
relevant instances without having to populate it in
&lt;code&gt;main&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Instead, let’s start with an empty map.&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb15-1"&gt;&lt;a href="#cb15-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;prettyInst&quot;&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb15-2"&gt;&lt;a href="#cb15-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ip &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; &lt;span class="fu"&gt;mempty&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The typechecker prevents us from using this instance without further
local instances since we don’t have any &lt;code&gt;HasPretty&lt;/code&gt; instances
yet.&lt;/p&gt;
&lt;p&gt;Fortunately, telling the type checker about global instances is quite
easy: We just have to implement &lt;code&gt;HasPretty&lt;/code&gt; for the type we
are writing an instance for.&lt;/p&gt;
&lt;p&gt;Since we don’t have an actual instance yet, this would still crash at
runtime; our instance map doesn’t have any implementations by
default.&lt;/p&gt;
&lt;p&gt;Consider this: In case the instance map does not contain an entry for
the type &lt;code&gt;pretty&lt;/code&gt; is called at, but it &lt;em&gt;is called&lt;/em&gt;
(meaning the &lt;code&gt;HasPretty&lt;/code&gt; constraint was satisfied), we know
that there &lt;em&gt;has to be a global instance&lt;/em&gt; and that &lt;em&gt;no local
instances are in scope&lt;/em&gt;. Thus, crucially, &lt;strong&gt;there is only a
single instance for &lt;code&gt;HasPretty&lt;/code&gt;, which is a regular global
instance&lt;/strong&gt;. If there is only a single instance, we don’t need to
deal with incoherence and we are able to use actual methods from
&lt;code&gt;HasPretty&lt;/code&gt; with confidence that they are coming from the
global instance with or without optimizations.&lt;/p&gt;
&lt;p&gt;What would possible methods on &lt;code&gt;HasPretty&lt;/code&gt; look like? We
still need to specify the implementation of our global instance
somewhere, so this would be a perfect place to put that.&lt;/p&gt;
&lt;p&gt;Now, whenever &lt;code&gt;pretty&lt;/code&gt; is called and detects a runtime
instance in its instance map, we know that the instance has been
overridden and &lt;code&gt;HasPretty&lt;/code&gt; is potentially contaminated, so we
use the instance from the instance map directly and ignore any methods
from &lt;code&gt;HasPretty&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;If there is no runtime instance, we know that the instance it is
called at has to be a global, coherent instance and we can safely use
the implementation from &lt;code&gt;HasPretty&lt;/code&gt; to maintain
coherence.&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb16-1"&gt;&lt;a href="#cb16-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-2"&gt;&lt;a href="#cb16-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    globalInst ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb16-3"&gt;&lt;a href="#cb16-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-4"&gt;&lt;a href="#cb16-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-5"&gt;&lt;a href="#cb16-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-6"&gt;&lt;a href="#cb16-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-7"&gt;&lt;a href="#cb16-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- This will never be called unless someone seriously messes with things, &lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-8"&gt;&lt;a href="#cb16-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- since `withPretty` always adds an instance to the ?prettyInst InstMap &lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-9"&gt;&lt;a href="#cb16-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    globalInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&quot;pretty: No instance found at runtime&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-10"&gt;&lt;a href="#cb16-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb16-11"&gt;&lt;a href="#cb16-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-12"&gt;&lt;a href="#cb16-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-13"&gt;&lt;a href="#cb16-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-14"&gt;&lt;a href="#cb16-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; M.lookup key (unInstMap &lt;span class="op"&gt;?&lt;/span&gt;prettyInst) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-15"&gt;&lt;a href="#cb16-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb16-16"&gt;&lt;a href="#cb16-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _pretty globalInst&lt;/span&gt;
&lt;span id="cb16-17"&gt;&lt;a href="#cb16-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; dict &lt;span class="ot"&gt;-&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb16-18"&gt;&lt;a href="#cb16-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _pretty &lt;span class="op"&gt;$&lt;/span&gt; unsafeCoerce dict&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This works!&lt;/p&gt;
&lt;p&gt;If we try the example from before…&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb17-1"&gt;&lt;a href="#cb17-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-2"&gt;&lt;a href="#cb17-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    globalInst &lt;span class="ot"&gt;=&lt;/span&gt; boringPretty&lt;/span&gt;
&lt;span id="cb17-3"&gt;&lt;a href="#cb17-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb17-4"&gt;&lt;a href="#cb17-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb17-5"&gt;&lt;a href="#cb17-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-6"&gt;&lt;a href="#cb17-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (pretty (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb17-7"&gt;&lt;a href="#cb17-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (withPretty nicePretty (pretty (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre
class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb18-1"&gt;&lt;a href="#cb18-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc &lt;span class="at"&gt;-O2&lt;/span&gt; Main.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./Main&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-2"&gt;&lt;a href="#cb18-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;Main.hs,&lt;/span&gt; Main.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-3"&gt;&lt;a href="#cb18-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; Main ...&lt;/span&gt;
&lt;span id="cb18-4"&gt;&lt;a href="#cb18-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-5"&gt;&lt;a href="#cb18-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;✨5✨&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;… everything works as expected, even with optimizations!&lt;/p&gt;
&lt;p&gt;There is actually not much boilerplate involved in this technique,
compared to regular type classes and instances.&lt;/p&gt;
&lt;p&gt;The main limitation is that types used in instances all have to
implement &lt;code&gt;Typeable&lt;/code&gt;, so we can only use this for relatively
simple instances.&lt;/p&gt;
&lt;p&gt;Defining a class is quite a bit more verbose since we have to define
a dictionary type, a &lt;code&gt;HasX&lt;/code&gt; class to carry the global
instance, a global instance for the associated implicit parameter as
well as functions to apply and override the active instance.&lt;/p&gt;
&lt;p&gt;To use our running example, the class definition&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb19-1"&gt;&lt;a href="#cb19-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb19-2"&gt;&lt;a href="#cb19-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    pretty ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;becomes&lt;/p&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb20-1"&gt;&lt;a href="#cb20-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb20-2"&gt;&lt;a href="#cb20-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    _pretty ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-3"&gt;&lt;a href="#cb20-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;}&lt;/span&gt;
&lt;span id="cb20-4"&gt;&lt;a href="#cb20-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-5"&gt;&lt;a href="#cb20-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-6"&gt;&lt;a href="#cb20-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    globalInst ::&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb20-7"&gt;&lt;a href="#cb20-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-8"&gt;&lt;a href="#cb20-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a&lt;span class="op"&gt;.&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-9"&gt;&lt;a href="#cb20-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-10"&gt;&lt;a href="#cb20-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-11"&gt;&lt;a href="#cb20-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; M.lookup key (unInstMap &lt;span class="op"&gt;?&lt;/span&gt;prettyInst) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-12"&gt;&lt;a href="#cb20-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Nothing&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb20-13"&gt;&lt;a href="#cb20-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _pretty globalInst&lt;/span&gt;
&lt;span id="cb20-14"&gt;&lt;a href="#cb20-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Just&lt;/span&gt; dict &lt;span class="ot"&gt;-&gt;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-15"&gt;&lt;a href="#cb20-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _pretty &lt;span class="op"&gt;$&lt;/span&gt; unsafeCoerce dict&lt;/span&gt;
&lt;span id="cb20-16"&gt;&lt;a href="#cb20-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-17"&gt;&lt;a href="#cb20-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-18"&gt;&lt;a href="#cb20-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-19"&gt;&lt;a href="#cb20-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-20"&gt;&lt;a href="#cb20-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    globalInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&quot;pretty: No instance found at runtime&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-21"&gt;&lt;a href="#cb20-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb20-22"&gt;&lt;a href="#cb20-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withPretty ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a b&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; ((&lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id="cb20-23"&gt;&lt;a href="#cb20-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withPretty dict x &lt;span class="ot"&gt;=&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-24"&gt;&lt;a href="#cb20-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; key &lt;span class="ot"&gt;=&lt;/span&gt; typeRepFingerprint (typeRep (&lt;span class="dt"&gt;Proxy&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Proxy&lt;/span&gt; a)) &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-25"&gt;&lt;a href="#cb20-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; prevInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="kw"&gt;in&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-26"&gt;&lt;a href="#cb20-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;case&lt;/span&gt; unsafeCoerce (&lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;LocalPrettyInst&lt;/span&gt;))&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;HasPretty&lt;/span&gt; a) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-27"&gt;&lt;a href="#cb20-27" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb20-28"&gt;&lt;a href="#cb20-28" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;prettyInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;MkInstMap&lt;/span&gt; (M.insert key (unsafeCoerce dict) prevInst) &lt;span class="kw"&gt;in&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb20-29"&gt;&lt;a href="#cb20-29" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Crucially, though, the boilerplate involved in &lt;em&gt;using&lt;/em&gt; these
overridable instances is pretty minimal and most of the boilerplate when
defining these ‘classes’ could be automated with TemplateHaskell.&lt;/p&gt;
&lt;p&gt;New global instances only have to implement &lt;code&gt;HasPretty&lt;/code&gt;,
which is a tiny bit less ergonomic than &lt;code&gt;Pretty&lt;/code&gt;, since we
have to implement the dictionary, not the methods and there are no
default implementations.&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb21-1"&gt;&lt;a href="#cb21-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-2"&gt;&lt;a href="#cb21-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    globalInst &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PrettyDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb21-3"&gt;&lt;a href="#cb21-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _pretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-4"&gt;&lt;a href="#cb21-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The only difference between a function that uses our overridable
&lt;code&gt;pretty&lt;/code&gt; and one that uses the regular &lt;code&gt;Pretty&lt;/code&gt;
type class is in the constraint, which changes from
&lt;code&gt;Pretty a&lt;/code&gt; to
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We could try to factor this out to a type synonym.&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb22-1"&gt;&lt;a href="#cb22-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Thereby completely eliminating any additonal boilerplate when using
&lt;code&gt;pretty&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;Let’s rewrite &lt;code&gt;pretty&lt;/code&gt; with a &lt;code&gt;Pretty a&lt;/code&gt;
constraint instead of the more complicated
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;. After
all, &lt;code&gt;Pretty&lt;/code&gt; is just a type synonym, so this should mean
exactly the same thing, right? …&lt;em&gt;right?&lt;/em&gt;&lt;/p&gt;
&lt;h2 id="it-all-comes-tumbling-down"&gt;It all comes tumbling down&lt;/h2&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb23-1"&gt;&lt;a href="#cb23-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; &lt;span class="dt"&gt;Pretty&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-2"&gt;&lt;a href="#cb23-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;pretty &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-3"&gt;&lt;a href="#cb23-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb23-4"&gt;&lt;a href="#cb23-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="op"&gt;:&lt;/span&gt;t pretty&lt;/span&gt;
&lt;span id="cb23-5"&gt;&lt;a href="#cb23-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;pretty ::&lt;/span&gt; (&lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="dt"&gt;Typeable&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Uh oh. The &lt;code&gt;?prettyInst :: InstMap&lt;/code&gt; constraint just…
disappeared?&lt;/p&gt;
&lt;p&gt;What happened here, is that when resolving&lt;a href="#fn4"
class="footnote-ref" id="fnref4" role="doc-noteref"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt; the
type synonym, GHC tried to simplify the constraint and removed the
monomorphic &lt;code&gt;?prettyInst :: InstMap&lt;/code&gt; constraint, since an
instance was found in the global context.&lt;/p&gt;
&lt;p&gt;This obviously sounds like a bug, but I am not certain that it
actually is. In fact, the real bug is probably that we were able to
define a global instance for &lt;code&gt;IP&lt;/code&gt; in the first place.&lt;/p&gt;
&lt;p&gt;Okay, we are unable to factor out the
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;
constraint with a type synonym. Since we have a custom
&lt;code&gt;HasPretty&lt;/code&gt; class anyway, we could try to include these as
superclasses in the style of &lt;a
href="https://blog.csongor.co.uk/opaque-constraint-synonyms"&gt;Opaque
constraint synonyms&lt;/a&gt; instead.&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb24-1"&gt;&lt;a href="#cb24-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;prettyInst&quot;&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;…except this doesn’t work. GHC does not allow implicit parameters in
superclasses, even if we explicitly write them as &lt;code&gt;IP&lt;/code&gt; class
constraints.&lt;/p&gt;
&lt;p&gt;This is a reasonable restriction because the time at which
dictionaries with super classes are constructed can be quite
unpredictable, so an implicit parameter superclass constraint will
probably not contain the intended value, but it &lt;em&gt;is&lt;/em&gt; annoying
since we have to keep the &lt;code&gt;?prettyInst :: InstMap&lt;/code&gt; constraint
around.&lt;/p&gt;
&lt;p&gt;We could at least try to factor out &lt;code&gt;Typeable&lt;/code&gt; though.&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb25-1"&gt;&lt;a href="#cb25-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Typeable&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb25-2"&gt;&lt;a href="#cb25-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This compiles and even runs correctly!&lt;/p&gt;
&lt;p&gt;…as long as we compile &lt;em&gt;with&lt;/em&gt; optimizations.&lt;a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;So, factoring out the
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;
constraint is not an option. Is there anything else we cannot do?&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb26-1"&gt;&lt;a href="#cb26-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a, &lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;prettyInst ::&lt;/span&gt; &lt;span class="dt"&gt;InstMap&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-2"&gt;&lt;a href="#cb26-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f &lt;span class="ot"&gt;=&lt;/span&gt; pretty&lt;/span&gt;
&lt;span id="cb26-3"&gt;&lt;a href="#cb26-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb26-4"&gt;&lt;a href="#cb26-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;g x &lt;span class="ot"&gt;=&lt;/span&gt; f x&lt;/span&gt;
&lt;span id="cb26-5"&gt;&lt;a href="#cb26-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb26-6"&gt;&lt;a href="#cb26-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="op"&gt;:&lt;/span&gt;t g&lt;/span&gt;
&lt;span id="cb26-7"&gt;&lt;a href="#cb26-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;g ::&lt;/span&gt; (&lt;span class="dt"&gt;Typeable&lt;/span&gt; a, &lt;span class="dt"&gt;HasPretty&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;String&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-8"&gt;&lt;a href="#cb26-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb26-9"&gt;&lt;a href="#cb26-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;main ::&lt;/span&gt; &lt;span class="dt"&gt;IO&lt;/span&gt; ()&lt;/span&gt;
&lt;span id="cb26-10"&gt;&lt;a href="#cb26-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-11"&gt;&lt;a href="#cb26-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- I am using instances for `Bool` here since we haven&#39;t defined a &lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-12"&gt;&lt;a href="#cb26-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;-- global instance for `HasPretty Bool` yet.&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-13"&gt;&lt;a href="#cb26-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (withPretty (&lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt;) (f &lt;span class="dt"&gt;True&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb26-14"&gt;&lt;a href="#cb26-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;putStrLn&lt;/span&gt; (withPretty (&lt;span class="dt"&gt;PrettyDict&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Bool&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt;) (g &lt;span class="dt"&gt;True&lt;/span&gt;))&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre
class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb27-1"&gt;&lt;a href="#cb27-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc Main.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./Main&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-2"&gt;&lt;a href="#cb27-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;Main.hs,&lt;/span&gt; Main.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-3"&gt;&lt;a href="#cb27-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; Main ...&lt;/span&gt;
&lt;span id="cb27-4"&gt;&lt;a href="#cb27-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;True&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-5"&gt;&lt;a href="#cb27-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Main:&lt;/span&gt; pretty: No instance found at runtime&lt;/span&gt;
&lt;span id="cb27-6"&gt;&lt;a href="#cb27-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;CallStack&lt;/span&gt; &lt;span class="er"&gt;(&lt;/span&gt;&lt;span class="ex"&gt;from&lt;/span&gt; HasCallStack&lt;span class="kw"&gt;)&lt;/span&gt;&lt;span class="bu"&gt;:&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-7"&gt;&lt;a href="#cb27-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="ex"&gt;error,&lt;/span&gt; called at Main.hs:55:18 in main:Main&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh, come on!&lt;/p&gt;
&lt;p&gt;As it turns out, when inferring the type for &lt;code&gt;g&lt;/code&gt;, GHC
omits the implicit parameter constraint and instead hard wires the empty
instance map from the global instance.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;withPretty&lt;/code&gt; still inserts a &lt;code&gt;HasPretty&lt;/code&gt;
instance, so the compiler cannot stop us from calling &lt;code&gt;g&lt;/code&gt; and
crashing at runtime.&lt;/p&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;We are able to replace type classes with overridable
&lt;code&gt;ImplicitParams&lt;/code&gt; and runtime type information based
dispatch.&lt;/li&gt;
&lt;li&gt;We can recover type safety, by using fake constraints for an empty
class so that incoherence is not an issue.&lt;/li&gt;
&lt;li&gt;To get proper global instances, we can extend the previously empty
class with a base implementation. We only ever use this implementation
if we are absolutely sure no local instance exists, so this is also
safe.&lt;/li&gt;
&lt;li&gt;Unfortunately, the global &lt;code&gt;ImplicitParams&lt;/code&gt; instance makes
&lt;code&gt;?prettyInst&lt;/code&gt; constraints extremely brittle and mistakes like
forgetting a type signature can remove the parameter and lead to runtime
crashes.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;To safely use this, we &lt;em&gt;always&lt;/em&gt; have to make sure to&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;type out the entire
&lt;code&gt;(Typeable a, HasPretty a, ?prettyInst :: InstMap)&lt;/code&gt;
constraint&lt;/li&gt;
&lt;li&gt;write a type signature whenever it might include
&lt;code&gt;?prettyInst&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Now, should you ever use any of this in anything that you might
possibly not want to break?&lt;/p&gt;
&lt;p&gt;Of course not. Global implicit parameters seem to be mostly uncharted
territory and I’m pretty sure their mere existence constitutes a
bug.&lt;/p&gt;
&lt;p&gt;Still, screwing around with broken features and pushing the limits of
Haskell is fun. I had a blast writing this and I hope it was enjoyable
to read as well! Maybe you even learned something today?&lt;/p&gt;
&lt;section class="footnotes footnotes-end-of-document"
role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;If you have not already, you should
probably read &lt;a href="/posts/unsafeCoerceDict.html"&gt;that post&lt;/a&gt; first
to understand the context of this and what ‘incoherence’ even means.&lt;a
href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;As far as I can tell, the reason for
this is to aid type inference. Without this dependency, GHC would be
unable to figure out the type of &lt;code&gt;?x&lt;/code&gt; even when a
&lt;code&gt;(?x :: Int)&lt;/code&gt; constraint is in scope. This is a little
frustrating though, since the functional dependency is a bit of a lie.
The type of &lt;code&gt;x&lt;/code&gt; is not &lt;em&gt;really&lt;/em&gt; only determined by its
name. It is determined by its name and the instance in the surrounding
context, but GHC cannot express that so it cheats and invents a
functional dependency.&lt;a href="#fnref2" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3" role="doc-endnote"&gt;&lt;p&gt;The terminology is a bit confusing
here. &lt;code&gt;TypeRep&lt;/code&gt; in &lt;code&gt;Data.Typeable&lt;/code&gt; is just a
representation of regular compile-time types, that is carried in
&lt;code&gt;Typeable&lt;/code&gt; constraints at runtime, not about the runtime
representation of values as in &lt;code&gt;type role representational&lt;/code&gt;.
Concretely this means, that newtypes like &lt;code&gt;Int&lt;/code&gt; and
&lt;code&gt;Sum Int&lt;/code&gt; will have the same runtime representation, but
their &lt;code&gt;TypeRep&lt;/code&gt;s will be different.&lt;a href="#fnref3"
class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4" role="doc-endnote"&gt;&lt;p&gt;The issue might have already happened
when &lt;em&gt;defining&lt;/em&gt; the type synonym. I’m not sure but the end result
is the same either way.&lt;a href="#fnref4" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5" role="doc-endnote"&gt;&lt;p&gt;Yeah…&lt;a href="#fnref5"
class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
</item><item>
    <title> Faking Local Instances with unsafeCoerce Dict</title>
    <link>https://prophetlabs.de/posts/unsafeCoerceDict.html</link>
    <guid isPremaLink="true">https://prophetlabs.de/posts/unsafeCoerceDict.html</guid>
    <pubDate>2022-3-18</pubDate>
    <description>



&lt;p&gt;When you first learned about Haskell’s &lt;code&gt;Monoid&lt;/code&gt; typeclass,
you were probably quite surprised to find out that there is no instance
for &lt;code&gt;Monoid Int&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After all, &lt;code&gt;(+)&lt;/code&gt; is an associative binary operation, and
&lt;code&gt;0&lt;/code&gt; acts as a unit element.&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;+&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb1-3"&gt;&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-4"&gt;&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason, as you will have learned is that this is not the
&lt;em&gt;only&lt;/em&gt; possible instance for &lt;code&gt;Monoid Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following instance is, in fact, just as valid.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;*&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might also be aware, that the way to work around this is to
declare newtype wrappers and to wrap and unwrap all &lt;code&gt;Int&lt;/code&gt;s
every time the Monoid instance is needed.&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; {&lt;span class="ot"&gt;getSum ::&lt;/span&gt; a}&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; {&lt;span class="ot"&gt;getProduct ::&lt;/span&gt; a}&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="dt"&gt;Sum&lt;/span&gt; x) &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; y) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; (x &lt;span class="op"&gt;+&lt;/span&gt; y)&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="dt"&gt;Product&lt;/span&gt; x) &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; y) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; (x &lt;span class="op"&gt;*&lt;/span&gt; y)&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-12"&gt;&lt;a href="#cb3-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-13"&gt;&lt;a href="#cb3-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-14"&gt;&lt;a href="#cb3-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; getSum &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;foldMap&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-15"&gt;&lt;a href="#cb3-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is a bit of boilerplate involved in defining the newtypes and
corresponding instances, but what is hard to swallow is that quite a bit
of boilerplate has to be included at &lt;em&gt;every single use site&lt;/em&gt;.&lt;a
href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If Haskell had local instances, this would not be an issue since we
would not be forced to commit to a single instance and could just tell
the compiler the instance we want without having to constantly wrap and
unwrap everything.&lt;a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="introducing-dict"&gt;Introducing &lt;code&gt;Dict&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;GHC uses a technique called &lt;em&gt;dictionary passing&lt;/em&gt; to compile
typeclass dictionaries. This means that in Core (GHC’s intermediate
language), &lt;code&gt;=&gt;&lt;/code&gt; is turned into &lt;code&gt;-&gt;&lt;/code&gt;. In
other words, &lt;em&gt;constraints become arguments&lt;/em&gt;, called
&lt;em&gt;dictionaries&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Why is that useful to know? Well, while there is no way to directly
access or construct these dictionaries, we &lt;em&gt;can&lt;/em&gt; reify them with
&lt;code&gt;Dict&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="ot"&gt;c ::&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the constraint &lt;code&gt;c&lt;/code&gt; appears in the type signature
of the &lt;code&gt;Dict&lt;/code&gt; constructor, the constructor stores the
corresponding dictionary, and whenever it is scrutinized in a pattern
match, the constraint is made available.&lt;/p&gt;
&lt;p&gt;Unfortunately, even with &lt;code&gt;Dict&lt;/code&gt;, there is no way to
construct a dictionary without defining an instance first.&lt;/p&gt;
&lt;p&gt;The only way to construct a ‘local’ instance then is to define an
instance for a newtype wrapper, but if we create a Dict from that
instance, we cannot use the newtype &lt;code&gt;Dict&lt;/code&gt; for our original
type, because &lt;code&gt;Dict (Monoid Int)&lt;/code&gt; and
&lt;code&gt;Dict (Monoid (Sum Int))&lt;/code&gt; are entirely separate types to the
typechecker.&lt;/p&gt;
&lt;p&gt;We hit quite the wall there. We know we could use the Dict for our
newtype, and we know it would be safe&lt;a href="#fn3" class="footnote-ref"
id="fnref3" role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; because newtypes are
erased at runtime, but the typechecker doesn’t allow us to use a newtype
Dict to get an instance for the original type.&lt;/p&gt;
&lt;p&gt;If there was just some way to bypass the typechecker…&lt;/p&gt;
&lt;h2 id="i-solemnly-swear-i-am-up-to-no-good"&gt;I solemnly swear I am up to
no good&lt;/h2&gt;
&lt;p&gt;Luckily for us: there is!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsafeCoerce :: forall a b. a -&gt; b&lt;/code&gt; lets us bypass the
typechecker by treating a value of &lt;em&gt;any&lt;/em&gt; (lifted) type as a value
of &lt;em&gt;any other&lt;/em&gt; (lifted) type.&lt;/p&gt;
&lt;p&gt;This is probably one of the most dangerous, if not &lt;em&gt;the&lt;/em&gt; most
dangerous function in GHC’s arsenal. If you’re not careful, you can
easily end up with segmentation faults.&lt;/p&gt;
&lt;p&gt;We know what we’re doing though, so let’s try it out!&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;monoidSumDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb5-2"&gt;&lt;a href="#cb5-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;monoidSumDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-3"&gt;&lt;a href="#cb5-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-4"&gt;&lt;a href="#cb5-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;monoidIntDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb5-5"&gt;&lt;a href="#cb5-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;monoidIntDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce monoidSumDict&lt;/span&gt;
&lt;span id="cb5-6"&gt;&lt;a href="#cb5-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-7"&gt;&lt;a href="#cb5-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- If we didn&#39;t include the type signature, GHC would be confused about the type of number we&#39;re using&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-8"&gt;&lt;a href="#cb5-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; monoidIntDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb5-9"&gt;&lt;a href="#cb5-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect! We just created an instance of &lt;code&gt;Monoid Int&lt;/code&gt;, that
only exists if we pattern match on &lt;code&gt;monoidIntDict&lt;/code&gt;. This
sounds a lot like local instances to me.&lt;/p&gt;
&lt;h2 id="lets-simplify-this"&gt;Let’s simplify this&lt;/h2&gt;
&lt;p&gt;What we have so far is already pretty cool, but having to write out a
pattern match every time is a bit inconvenient.&lt;/p&gt;
&lt;p&gt;Fortunately, we can easily factor out the pattern match by turning it
into a function.&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb6-1"&gt;&lt;a href="#cb6-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb6-2"&gt;&lt;a href="#cb6-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withDict d x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; d &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb6-3"&gt;&lt;a href="#cb6-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb6-4"&gt;&lt;a href="#cb6-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withDict monoidIntDict &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb6-5"&gt;&lt;a href="#cb6-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That &lt;code&gt;(c =&gt; a)&lt;/code&gt; argument might look a bit strange, but
this is exactly what we’re trying to do: Take a value or function with a
constraint and remove that constraint by inserting the instance stored
in our &lt;code&gt;Dict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can do even better. The only way to construct one of our ‘local’
Dicts is to create a &lt;code&gt;Dict&lt;/code&gt; for a newtype and cast that to a
&lt;code&gt;Dict&lt;/code&gt; for the original type using &lt;code&gt;unsafeCoerce&lt;/code&gt;,
but users of our library really shouldn’t have to write their own
&lt;code&gt;Dict&lt;/code&gt; definition, let alone use
&lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb7-1"&gt;&lt;a href="#cb7-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c1 c2 d&lt;span class="op"&gt;.&lt;/span&gt; c1 &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c2 &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb7-2"&gt;&lt;a href="#cb7-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; c2Dict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb7-3"&gt;&lt;a href="#cb7-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-4"&gt;&lt;a href="#cb7-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        c1Dict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c1&lt;/span&gt;
&lt;span id="cb7-5"&gt;&lt;a href="#cb7-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        c1Dict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-6"&gt;&lt;a href="#cb7-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        c2Dict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c2&lt;/span&gt;
&lt;span id="cb7-7"&gt;&lt;a href="#cb7-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        c2Dict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce c1Dict &lt;/span&gt;
&lt;span id="cb7-8"&gt;&lt;a href="#cb7-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb7-9"&gt;&lt;a href="#cb7-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)) &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb7-10"&gt;&lt;a href="#cb7-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, all that users have to do is supply the right type applications
and &lt;code&gt;withLocal&lt;/code&gt; is going to do everything else for them.
Nice!&lt;/p&gt;
&lt;h2 id="hey-google-whats-a-segfault"&gt;Hey Google, what’s a segfault?&lt;/h2&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb8-1"&gt;&lt;a href="#cb8-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Eq&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Num&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;$&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-2"&gt;&lt;a href="#cb8-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;fish&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;Job&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;, &#39;ghci unsafeCoerceDict&lt;span class="op"&gt;.&lt;/span&gt;hs&#39; terminated by signal &lt;span class="dt"&gt;SIGSEGV&lt;/span&gt; (&lt;span class="dt"&gt;Address&lt;/span&gt; boundary &lt;span class="fu"&gt;error&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh no&lt;a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;…&lt;/p&gt;
&lt;p&gt;We just used &lt;code&gt;unsafeCoerce&lt;/code&gt; to cast a
&lt;code&gt;Dict (Eq Bool)&lt;/code&gt; to a &lt;code&gt;Dict (Num Int)&lt;/code&gt;. We really
shouldn’t be able to do this.&lt;/p&gt;
&lt;p&gt;The issue here is that &lt;code&gt;withLocal&lt;/code&gt; places no constraints
on the — well — &lt;em&gt;constraints&lt;/em&gt; (&lt;code&gt;c1&lt;/code&gt; and
&lt;code&gt;c2&lt;/code&gt;). In reality, we need both constraints to contain the
same typeclass and to only differ in the &lt;em&gt;argument&lt;/em&gt; to that
class.&lt;/p&gt;
&lt;p&gt;Let’s do that.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c a b d&lt;span class="op"&gt;.&lt;/span&gt; (c a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c b &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cbDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        caDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c a)&lt;/span&gt;
&lt;span id="cb9-5"&gt;&lt;a href="#cb9-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        caDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-6"&gt;&lt;a href="#cb9-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        cbDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c b)&lt;/span&gt;
&lt;span id="cb9-7"&gt;&lt;a href="#cb9-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        cbDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce caDict &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we did not change anything about the implementation. We
just constrained its type signature.&lt;/p&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;withLocal&lt;/code&gt; can still segfault because
there are still no constraints on &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. We
could, for instance, still try to convert a &lt;code&gt;Monoid String&lt;/code&gt;
to a &lt;code&gt;Monoid Int&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="why-did-this-even-work-before"&gt;Why did this even work
before?&lt;/h2&gt;
&lt;p&gt;The reason why this function is safe on &lt;code&gt;Sum Int&lt;/code&gt; and
&lt;code&gt;Int&lt;/code&gt; is that &lt;code&gt;Sum Int&lt;/code&gt; is just a newtype wrapper
over &lt;code&gt;Int&lt;/code&gt;, and newtypes are completely erased at runtime. So
a function of type &lt;code&gt;Sum Int -&gt; b&lt;/code&gt; really becomes a
function of type &lt;code&gt;Int -&gt; b&lt;/code&gt; at runtime.&lt;/p&gt;
&lt;p&gt;Thus we can safely&lt;a href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; cast it to &lt;code&gt;Int -&gt; b&lt;/code&gt;
using &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; don’t have the same runtime
representation, so we cannot safely cast
&lt;code&gt;Dict (Monoid String)&lt;/code&gt; to &lt;code&gt;Dict (Monoid Int)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately for us, Haskell does actually provide a way to constrain
a function to types with the same runtime representation:
&lt;code&gt;Coercible&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;If we adjust our function to include a &lt;code&gt;Coercible a b&lt;/code&gt;
constraint, we finally end up with a safe implementation that doesn’t
segfault!&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c a b d&lt;span class="op"&gt;.&lt;/span&gt; (c a, &lt;span class="dt"&gt;Coercible&lt;/span&gt; a b) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c b &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb10-2"&gt;&lt;a href="#cb10-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cbDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb10-3"&gt;&lt;a href="#cb10-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-4"&gt;&lt;a href="#cb10-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        caDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c a)&lt;/span&gt;
&lt;span id="cb10-5"&gt;&lt;a href="#cb10-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        caDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-6"&gt;&lt;a href="#cb10-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        cbDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c b)&lt;/span&gt;
&lt;span id="cb10-7"&gt;&lt;a href="#cb10-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        cbDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce caDict &lt;/span&gt;
&lt;span id="cb10-8"&gt;&lt;a href="#cb10-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-9"&gt;&lt;a href="#cb10-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb10-10"&gt;&lt;a href="#cb10-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we still had to use &lt;code&gt;unsafeCoerce&lt;/code&gt; instead of
&lt;code&gt;coerce&lt;/code&gt;. Just because &lt;code&gt;a&lt;/code&gt; can be coerced to
&lt;code&gt;b&lt;/code&gt;, doesn’t mean GHC will allow you to cast
&lt;code&gt;Dict (c a)&lt;/code&gt; to &lt;code&gt;Dict (c b)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="expanding"&gt;Expanding&lt;/h2&gt;
&lt;p&gt;What we have so far is already pretty cool, but we can do even
better.&lt;/p&gt;
&lt;p&gt;So far, all our local instances were limited by us having to write an
instance for a newtype wrapper and so our instances could not include
entirely arbitrary functions.&lt;/p&gt;
&lt;p&gt;We couldn’t, for example, declare a local function depending on a
local variable and use that in an instance, because instances have to be
written at the top level and therefore can’t include local
variables.&lt;/p&gt;
&lt;p&gt;Fortunately, by selling a bit more of our soul to the type checker,
we can work around this limitation!&lt;/p&gt;
&lt;p&gt;At runtime, dictionaries (not &lt;code&gt;Dict&lt;/code&gt;s) are really just
regular data types, so there is no reason, why we shouldn’t be able to
fake them with &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note, that &lt;code&gt;Dict&lt;/code&gt; actually stores the runtime dictionary
as a lifted field, so if we want to coerce to &lt;code&gt;Dict&lt;/code&gt;, we need
to add a layer of indirection.&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb11-1"&gt;&lt;a href="#cb11-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;FakeDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FakeDict&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now for the runtime dictionary, let’s look at the definition of the
&lt;code&gt;Eq&lt;/code&gt; typeclass.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb12-1"&gt;&lt;a href="#cb12-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-2"&gt;&lt;a href="#cb12-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;  (==) ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-3"&gt;&lt;a href="#cb12-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;  (/=) ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-4"&gt;&lt;a href="#cb12-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="ot"&gt;{-# MINIMAL (==) | (/=) #-}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Eq&lt;/code&gt; has two methods &lt;code&gt;(==)&lt;/code&gt; and
&lt;code&gt;(/=)&lt;/code&gt;, so our datatype also has to have two fields with
matching types.&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb13-1"&gt;&lt;a href="#cb13-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;EqDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;EqDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb13-2"&gt;&lt;a href="#cb13-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        _eq  ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-3"&gt;&lt;a href="#cb13-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _neq ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-4"&gt;&lt;a href="#cb13-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we need a function to make &lt;code&gt;unsafeCoere&lt;/code&gt; a little less
unsafe.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb14-1"&gt;&lt;a href="#cb14-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withFakeDictUnsafe ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c d a&lt;span class="op"&gt;.&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb14-2"&gt;&lt;a href="#cb14-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDictUnsafe d x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; unsafeCoerce (&lt;span class="dt"&gt;FakeDict&lt;/span&gt; d)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-3"&gt;&lt;a href="#cb14-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This already works for simple classes like &lt;code&gt;Eq&lt;/code&gt;, but right
now we can’t handle classes with superclasses like &lt;code&gt;Monoid&lt;/code&gt;,
because we have no way of storing the superclass dictionary in our fake
dictionary.&lt;/p&gt;
&lt;p&gt;In order to include the dictionary, we have to expand our
&lt;code&gt;MonoidDict&lt;/code&gt; to a GADT.&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb15-1"&gt;&lt;a href="#cb15-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;MonoidDict&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb15-2"&gt;&lt;a href="#cb15-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;MonoidDict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb15-3"&gt;&lt;a href="#cb15-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        _mempty  ::&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb15-4"&gt;&lt;a href="#cb15-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _mappend ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb15-5"&gt;&lt;a href="#cb15-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _mconcat ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;/span&gt;
&lt;span id="cb15-6"&gt;&lt;a href="#cb15-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    } &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;MonoidDict&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And… that’s it!&lt;/p&gt;
&lt;p&gt;We can now actually write useful functions that we couldn’t just
emulate by wrapping everything in a newtype.&lt;/p&gt;
&lt;p&gt;As an example, let’s consider a function that (locally) implements a
&lt;code&gt;Monoid&lt;/code&gt; instance for a type, which only implements
&lt;code&gt;Semigroup&lt;/code&gt;, based on a provided default argument for
&lt;code&gt;mempty&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb16-1"&gt;&lt;a href="#cb16-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withSemigroupAsMonoid ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a b&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id="cb16-2"&gt;&lt;a href="#cb16-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withSemigroupAsMonoid d &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDictUnsafe &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; a) (&lt;span class="dt"&gt;MonoidDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb16-3"&gt;&lt;a href="#cb16-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _mempty  &lt;span class="ot"&gt;=&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb16-4"&gt;&lt;a href="#cb16-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,   _mappend &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb16-5"&gt;&lt;a href="#cb16-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,   _mconcat &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldr&lt;/span&gt; (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) d&lt;/span&gt;
&lt;span id="cb16-6"&gt;&lt;a href="#cb16-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We couldn’t use a newtype instance, since
&lt;code&gt;withSemigroupAsMonoid&lt;/code&gt; uses the function parameter
&lt;code&gt;d&lt;/code&gt; in its instance definition.&lt;/p&gt;
&lt;h2 id="template-haskell"&gt;Template Haskell&lt;/h2&gt;
&lt;p&gt;Writing all these Dict types by hand is not just annoying, but also
quite dangerous because they are not automatically kept in sync with the
corresponding type classes, so if one of those changes and we forget to
update the Dict, the types are not actually compatible anymore.&lt;/p&gt;
&lt;p&gt;We can use some TemplateHaskell to automate the process and
(hopefully) avoid further segfaults.&lt;/p&gt;
&lt;p&gt;My experience with TemplateHaskell is pretty limited, so I’m not
going to pretend like this is a great implementation.&lt;a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb17-1"&gt;&lt;a href="#cb17-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;makeDict ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; [&lt;span class="dt"&gt;Dec&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb17-2"&gt;&lt;a href="#cb17-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict cname &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-3"&gt;&lt;a href="#cb17-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    reify cname &lt;span class="op"&gt;&gt;&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt; &lt;span class="co"&gt;-- (1)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-4"&gt;&lt;a href="#cb17-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;ClassI&lt;/span&gt; cdec is &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cdec &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-5"&gt;&lt;a href="#cb17-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="dt"&gt;ClassD&lt;/span&gt; cxt cname tvs _ meths &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; [&lt;/span&gt;
&lt;span id="cb17-6"&gt;&lt;a href="#cb17-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        dataCon [] dname tvs &lt;span class="dt"&gt;Nothing&lt;/span&gt; [&lt;span class="dt"&gt;ForallC&lt;/span&gt; (&lt;span class="fu"&gt;map&lt;/span&gt; (addSpecificity &lt;span class="dt"&gt;SpecifiedSpec&lt;/span&gt;) tvs) cxt &lt;/span&gt;
&lt;span id="cb17-7"&gt;&lt;a href="#cb17-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                            &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;RecGadtC&lt;/span&gt; [dname] (&lt;span class="fu"&gt;map&lt;/span&gt; methodToVarBangType meths) appliedFakeType] [] &lt;span class="co"&gt;-- (2)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-8"&gt;&lt;a href="#cb17-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    ]&lt;/span&gt;
&lt;span id="cb17-9"&gt;&lt;a href="#cb17-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-10"&gt;&lt;a href="#cb17-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    dataCon &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; (meths, cxt) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-11"&gt;&lt;a href="#cb17-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        ([_], []) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; \cxt name tvs k [cs] ds &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;NewtypeD&lt;/span&gt; cxt name tvs k cs ds &lt;span class="co"&gt;-- (4)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-12"&gt;&lt;a href="#cb17-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;DataD&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-13"&gt;&lt;a href="#cb17-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    dname &lt;span class="ot"&gt;=&lt;/span&gt; mkName &lt;span class="op"&gt;$&lt;/span&gt; nameBase cname &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;Dict&quot;&lt;/span&gt; &lt;span class="co"&gt;-- (3)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-14"&gt;&lt;a href="#cb17-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    &lt;/span&gt;
&lt;span id="cb17-15"&gt;&lt;a href="#cb17-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    methodToVarBangType (&lt;span class="dt"&gt;SigD&lt;/span&gt; n t) &lt;span class="ot"&gt;=&lt;/span&gt; (mkName (&lt;span class="st"&gt;&quot;_&quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; nameBase n), &lt;span class="dt"&gt;Bang&lt;/span&gt; &lt;span class="dt"&gt;SourceNoUnpack&lt;/span&gt; &lt;span class="dt"&gt;NoSourceStrictness&lt;/span&gt;, t)&lt;/span&gt;
&lt;span id="cb17-16"&gt;&lt;a href="#cb17-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    &lt;/span&gt;
&lt;span id="cb17-17"&gt;&lt;a href="#cb17-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    appliedFakeType  &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldl&lt;/span&gt; &lt;span class="dt"&gt;AppT&lt;/span&gt; (&lt;span class="dt"&gt;ConT&lt;/span&gt; dname) (&lt;span class="fu"&gt;map&lt;/span&gt; (&lt;span class="dt"&gt;VarT&lt;/span&gt; &lt;span class="op"&gt;.&lt;/span&gt; tyVarName) tvs)&lt;/span&gt;
&lt;span id="cb17-18"&gt;&lt;a href="#cb17-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    appliedClassType &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldl&lt;/span&gt; &lt;span class="dt"&gt;AppT&lt;/span&gt; (&lt;span class="dt"&gt;ConT&lt;/span&gt; cname) (&lt;span class="fu"&gt;map&lt;/span&gt; (&lt;span class="dt"&gt;VarT&lt;/span&gt; &lt;span class="op"&gt;.&lt;/span&gt; tyVarName) tvs)&lt;/span&gt;
&lt;span id="cb17-19"&gt;&lt;a href="#cb17-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb17-20"&gt;&lt;a href="#cb17-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    addSpecificity s (&lt;span class="dt"&gt;PlainTV&lt;/span&gt; n _) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PlainTV&lt;/span&gt; n s&lt;/span&gt;
&lt;span id="cb17-21"&gt;&lt;a href="#cb17-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    addSpecificity s (&lt;span class="dt"&gt;KindedTV&lt;/span&gt; n _ k) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;KindedTV&lt;/span&gt; n s k&lt;/span&gt;
&lt;span id="cb17-22"&gt;&lt;a href="#cb17-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb17-23"&gt;&lt;a href="#cb17-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    tyVarName (&lt;span class="dt"&gt;PlainTV&lt;/span&gt; n _) &lt;span class="ot"&gt;=&lt;/span&gt; n&lt;/span&gt;
&lt;span id="cb17-24"&gt;&lt;a href="#cb17-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    tyVarName (&lt;span class="dt"&gt;KindedTV&lt;/span&gt; n _ _) &lt;span class="ot"&gt;=&lt;/span&gt; n&lt;/span&gt;
&lt;span id="cb17-25"&gt;&lt;a href="#cb17-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;fail&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&quot;Not a class: &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; cname&lt;/span&gt;
&lt;span id="cb17-26"&gt;&lt;a href="#cb17-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;fail&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&quot;Not a class: &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; cname&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important steps are these:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;We get the class definition using &lt;code&gt;reify&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We can use that definition to construct a record GADT
(&lt;code&gt;RecGadtC&lt;/code&gt;) with one field for every class method.&lt;/li&gt;
&lt;li&gt;The new GADT is called &lt;code&gt;&lt;ClassName&gt;Dict&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If there is only a single method and no superclass, we construct a
newtype instead. Note that this step is not just an optimization, but
absolutely crucial, since a &lt;code&gt;data&lt;/code&gt; constructor has one more
level of indirection than a newtype, and confusing the two would lead to
a segfault.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We actually get another benefit from generating our instance. Since
we know, that using &lt;code&gt;withFakeDictUnsafe&lt;/code&gt; with our generated
&lt;code&gt;MonoidDict&lt;/code&gt; is safe, we can use a (non-exported) type class
and a function &lt;code&gt;withFakeDict&lt;/code&gt; to constrain arguments to
&lt;em&gt;safe&lt;/em&gt; (i.e. generated) dictionaries.&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb18-1"&gt;&lt;a href="#cb18-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;FakeDictFor&lt;/span&gt; (&lt;span class="ot"&gt;c ::&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) (&lt;span class="ot"&gt;d ::&lt;/span&gt; &lt;span class="dt"&gt;Type&lt;/span&gt;) &lt;span class="op"&gt;|&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; c&lt;/span&gt;
&lt;span id="cb18-2"&gt;&lt;a href="#cb18-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb18-3"&gt;&lt;a href="#cb18-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withFakeDict ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; d c a&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;FakeDictFor&lt;/span&gt; c d &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb18-4"&gt;&lt;a href="#cb18-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDict &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDictUnsafe&lt;/span&gt;
&lt;span id="cb18-5"&gt;&lt;a href="#cb18-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb18-6"&gt;&lt;a href="#cb18-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;makeDict ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; [&lt;span class="dt"&gt;Dec&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb18-7"&gt;&lt;a href="#cb18-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict cname &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-8"&gt;&lt;a href="#cb18-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;{- ... -}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-9"&gt;&lt;a href="#cb18-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    [d|instance FakeDictFor $(pure appliedClassType) $(pure appliedFakeType)|]&lt;/span&gt;
&lt;span id="cb18-10"&gt;&lt;a href="#cb18-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;{- ... -}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="incoherence"&gt;Incoherence&lt;/h2&gt;
&lt;p&gt;Unfortunately, both &lt;code&gt;withLocal&lt;/code&gt; and
&lt;code&gt;withFakeDictUnsafe&lt;/code&gt; have a pretty serious flaw. Usually,
whenever we use a typeclass method in Haskell, there are essentially two
possibilities: either &lt;em&gt;no&lt;/em&gt; instance exists or there is
&lt;em&gt;exactly one&lt;/em&gt; and the compiler picks that one. This is called
&lt;em&gt;Coherence&lt;/em&gt; and is also the reason why all in-scope typeclass
instances are always exported from a module.&lt;/p&gt;
&lt;p&gt;The issue with our functions is that in case there is already an
instance for the typeclass, they introduce a second instance and break
the compiler’s Coherence assumption.&lt;/p&gt;
&lt;p&gt;As an example, let’s say we want to introduce a local instance for
&lt;code&gt;Show Int&lt;/code&gt;. If we do this, using &lt;code&gt;withLocal&lt;/code&gt;&lt;a
href="#fn7" class="footnote-ref" id="fnref7"
role="doc-noteref"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;, which instance is the compiler
going to pick? Let’s find out!&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb19-1"&gt;&lt;a href="#cb19-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;FancyShow&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FancyShow&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb19-2"&gt;&lt;a href="#cb19-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; (&lt;span class="dt"&gt;FancyShow&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb19-3"&gt;&lt;a href="#cb19-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;show&lt;/span&gt; (&lt;span class="dt"&gt;FancyShow&lt;/span&gt; x) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&quot;⭐&quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; x &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;⭐&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb19-4"&gt;&lt;a href="#cb19-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb19-5"&gt;&lt;a href="#cb19-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;FancyShow&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre
class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb20-1"&gt;&lt;a href="#cb20-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc unsafeCoerceDict.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./unsafeCoerceDict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-2"&gt;&lt;a href="#cb20-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;unsafeCoerceDict.hs,&lt;/span&gt; unsafeCoerceDict.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-3"&gt;&lt;a href="#cb20-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; unsafeCoerceDict ...&lt;/span&gt;
&lt;span id="cb20-4"&gt;&lt;a href="#cb20-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;⭐5⭐&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nice! It seems like we can override instances using
&lt;code&gt;withLocal&lt;/code&gt;. Let’s try that with optimizations&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre
class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb21-1"&gt;&lt;a href="#cb21-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc &lt;span class="at"&gt;-O&lt;/span&gt; unsafeCoerceDict.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./unsafeCoerceDict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-2"&gt;&lt;a href="#cb21-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;unsafeCoerceDict.hs,&lt;/span&gt; unsafeCoerceDict.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-3"&gt;&lt;a href="#cb21-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; unsafeCoerceDict ...&lt;/span&gt;
&lt;span id="cb21-4"&gt;&lt;a href="#cb21-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh no… optimizations can change the semantics of our program by
picking the original instance, that we tried to override. We really
don’t want that.&lt;/p&gt;
&lt;p&gt;To make matters worse, there is no way to prevent incoherent usage
without having to include Template Haskell at call sites, since there is
no way to write a type like
&lt;code&gt;Not (Eq a) =&gt; (Eq a =&gt; b) -&gt; b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s not that bad though. As long as we make sure to never try to
override existing instances, we are safe.&lt;/p&gt;
&lt;h2 id="implicitparams"&gt;ImplicitParams&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;withFakeDict&lt;/code&gt; might remind you of a different Haskell
feature, namely &lt;code&gt;ImplicitParams&lt;/code&gt;. And indeed, we can directly
interoperate with &lt;code&gt;ImplicitParams&lt;/code&gt; using
&lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An implicit parameter constraint like&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb22-1"&gt;&lt;a href="#cb22-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;x ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-2"&gt;&lt;a href="#cb22-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;x &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is really just syntactic sugar for&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb23-1"&gt;&lt;a href="#cb23-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-2"&gt;&lt;a href="#cb23-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f &lt;span class="ot"&gt;=&lt;/span&gt; ip &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where IP is a regular type class defined in
&lt;code&gt;GHC.Classes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What’s really cool about this is that we can actually define an
&lt;code&gt;IP&lt;/code&gt; constraint using &lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So instead of&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb24-1"&gt;&lt;a href="#cb24-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can write&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb25-1"&gt;&lt;a href="#cb25-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDict &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;IPDict&lt;/span&gt; &lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) (&lt;span class="dt"&gt;IPDict&lt;/span&gt; {_ip &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;}) f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and get the exact same behavior!&lt;/p&gt;
&lt;p&gt;This means that &lt;code&gt;withFakeDict&lt;/code&gt; is strictly more powerful
than ImplicitParams, but it also shares ImplicitParams’ &lt;a
href="https://chrisdone.com/posts/whats-wrong-with-implicitparams/"&gt;somewhat
famous&lt;/a&gt; &lt;a
href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/implicit_parameters.html#implicit-parameters-and-polymorphic-recursion"&gt;issues&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="configurable-trace"&gt;Configurable trace&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Debug.Trace.trace&lt;/code&gt; can be a very useful function for
quick debugging. Want to know what this intermediate expression
evaluates to? Just write it to stderr using &lt;code&gt;trace&lt;/code&gt;. Want to
know what values this function is called with? You can use trace for
that.&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb26-1"&gt;&lt;a href="#cb26-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-2"&gt;&lt;a href="#cb26-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f x &lt;span class="op"&gt;|&lt;/span&gt; trace (&lt;span class="st"&gt;&quot;x = &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; x) &lt;span class="dt"&gt;False&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&quot;unreachable&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-3"&gt;&lt;a href="#cb26-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;trace&lt;/code&gt; is not really suited for slightly
more permanent tracing, since there is no way to turn it off or to
change the target it writes to.&lt;/p&gt;
&lt;p&gt;If we wanted to improve trace, we would have to somehow pass a
configuration without &lt;em&gt;actually&lt;/em&gt; passing it manually to every
single function. Sounds a lot like type classes to me!&lt;/p&gt;
&lt;p&gt;Let’s try that. We should also probably use &lt;code&gt;Text&lt;/code&gt; instead
of &lt;code&gt;String&lt;/code&gt;, while we’re at it.&lt;/p&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb27-1"&gt;&lt;a href="#cb27-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-2"&gt;&lt;a href="#cb27-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make filtering easier, we should probably also accept some kind of
trace level. We could just accept an integer, but parameterizing our
class over the type of the trace level is more general.&lt;/p&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb28-1"&gt;&lt;a href="#cb28-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb28-2"&gt;&lt;a href="#cb28-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cool. Functions that want to perform logging now need an additional
&lt;code&gt;Trace lvl&lt;/code&gt; constraint, that supplies the actual
implementation.&lt;/p&gt;
&lt;p&gt;How do we pick the implementation though? If you’ve paid attention so
far, the answer should be obvious: We construct a fake dictionary using
&lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb29-1"&gt;&lt;a href="#cb29-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-2"&gt;&lt;a href="#cb29-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-3"&gt;&lt;a href="#cb29-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-4"&gt;&lt;a href="#cb29-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict &#39;&lt;span class="dt"&gt;&#39;Trace&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-5"&gt;&lt;a href="#cb29-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-6"&gt;&lt;a href="#cb29-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runTraceStderr ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-7"&gt;&lt;a href="#cb29-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runTraceStderr &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;TraceDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb29-8"&gt;&lt;a href="#cb29-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _trace _ &lt;span class="ot"&gt;=&lt;/span&gt; Debug.Trace.trace&lt;/span&gt;
&lt;span id="cb29-9"&gt;&lt;a href="#cb29-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;
&lt;span id="cb29-10"&gt;&lt;a href="#cb29-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-11"&gt;&lt;a href="#cb29-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;ignoreTrace ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-12"&gt;&lt;a href="#cb29-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ignoreTrace &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;TraceDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb29-13"&gt;&lt;a href="#cb29-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _trace _ _ x &lt;span class="ot"&gt;=&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb29-14"&gt;&lt;a href="#cb29-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One issue that might still come up is that someone could
theoretically define a top-level instance of &lt;code&gt;Trace lvl&lt;/code&gt;,
which would introduce incoherence and completely break our system. To
prevent that, we can hide the actual implementation in a class
&lt;code&gt;_Trace&lt;/code&gt;, that we don’t actually export. We can then define a
type synonym &lt;code&gt;Trace&lt;/code&gt; that we &lt;em&gt;do&lt;/em&gt; export. This way,
users of our library can still reference Trace through our type synonym,
but cannot define top-level instances since instances cannot be defined
for type synonyms of type classes.&lt;/p&gt;
&lt;div class="sourceCode" id="cb30"&gt;&lt;pre
class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb30-1"&gt;&lt;a href="#cb30-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; _Trace lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb30-2"&gt;&lt;a href="#cb30-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-3"&gt;&lt;a href="#cb30-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-4"&gt;&lt;a href="#cb30-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict &#39;&#39;_Trace&lt;/span&gt;
&lt;span id="cb30-5"&gt;&lt;a href="#cb30-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-6"&gt;&lt;a href="#cb30-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; _Trace&lt;/span&gt;
&lt;span id="cb30-7"&gt;&lt;a href="#cb30-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-8"&gt;&lt;a href="#cb30-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runTraceStderr ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-9"&gt;&lt;a href="#cb30-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runTraceStderr &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;Trace_Dict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb30-10"&gt;&lt;a href="#cb30-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _trace _ &lt;span class="ot"&gt;=&lt;/span&gt; Debug.Trace.trace&lt;/span&gt;
&lt;span id="cb30-11"&gt;&lt;a href="#cb30-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;
&lt;span id="cb30-12"&gt;&lt;a href="#cb30-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-13"&gt;&lt;a href="#cb30-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;ignoreTrace ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-14"&gt;&lt;a href="#cb30-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ignoreTrace &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;Trace_Dict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb30-15"&gt;&lt;a href="#cb30-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _trace _ _ x &lt;span class="ot"&gt;=&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb30-16"&gt;&lt;a href="#cb30-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nice! We just defined a fairly extensible little tracing library in
less than 20 lines of code.&lt;/p&gt;
&lt;p&gt;Here is why this is a good application of fake local instances&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is no reason to manually implement the &lt;code&gt;Trace&lt;/code&gt; type
class, so we were able to hide it completely and fully prevent
incoherence.&lt;/li&gt;
&lt;li&gt;In case we made a mistake or this whole approach is fundamentally
flawed and GHC decides to pick the wrong instance, nothing major breaks.
(You can never be entirely sure with &lt;code&gt;unsafeCoerce&lt;/code&gt; tricks
like this)&lt;/li&gt;
&lt;li&gt;This is really easy to implement, and much less limited than most
alternative approaches (Logging monads/effects, global
&lt;code&gt;IORef&lt;/code&gt;s, …)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Now, what did we learn from all of this?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is possible to transfer instances between newtypes.&lt;/li&gt;
&lt;li&gt;This approach can be expanded to allow the inclusion of arbitrary
functions as instance methods.&lt;/li&gt;
&lt;li&gt;All segfaults stemming from non-unsafe functions can be avoided and
it is possible to generate most boilerplate.&lt;/li&gt;
&lt;li&gt;Incoherence, stemming from multiple instances being available at
once, is an issue.&lt;/li&gt;
&lt;li&gt;ImplicitParams can be emulated with local instances.&lt;/li&gt;
&lt;li&gt;A tiny extensible tracing library is a pretty cool application of
local instances.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Does this mean, you should throw all your newtypes out of the window?
No.&lt;/p&gt;
&lt;p&gt;Does this mean, you should use the code from this article in
production? Probably not. You should really know what you’re doing if
you want to use anything in production that is based on
&lt;code&gt;unsafeCoerce&lt;/code&gt;. That said, if you want to try this out for
yourself, the code is available in a &lt;a
href="https://github.com/Innf107/fakedict"&gt;small library on github&lt;/a&gt;,
including &lt;code&gt;trace&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately, I hope that you learned a nice little trick today. You
never know when it might come in handy.&lt;/p&gt;
&lt;section class="footnotes footnotes-end-of-document"
role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;In this particular example, most
boilerplate could be eliminated by using &lt;code&gt;Sum&lt;/code&gt;’s
&lt;code&gt;Num&lt;/code&gt; instance, but in most real scenarios it’s unfortunately
not that simple.&lt;a href="#fnref1" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;There are very good reasons why
Haskell doesn’t have local instances, but we’ll get to that.&lt;a
href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3" role="doc-endnote"&gt;&lt;p&gt;Well… we’ll see about that.&lt;a
href="#fnref3" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4" role="doc-endnote"&gt;&lt;p&gt;I told you, unsafeCoerce was
dangerous…&lt;a href="#fnref4" class="footnote-back"
role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5" role="doc-endnote"&gt;&lt;p&gt;&lt;em&gt;safe&lt;/em&gt; here just means that it
doesn’t segfault. We’ll get to other meanings of safe, don’t worry!&lt;a
href="#fnref5" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6" role="doc-endnote"&gt;&lt;p&gt;Feel free to &lt;a
href="https://github.com/Innf107/fakedict/tree/main/src/Fakedict/TH.hs"&gt;submit
a pull request&lt;/a&gt; if you would like to write a better implementation&lt;a
href="#fnref6" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7" role="doc-endnote"&gt;&lt;p&gt;I did not use
&lt;code&gt;withFakeDict&lt;/code&gt; here, since &lt;code&gt;Show&lt;/code&gt; has a few
additional methods that we would have had to implement manually&lt;a
href="#fnref7" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;</description>
</item>
    </channel>
</rss>