<rss version="2.0">
    <channel>
        <title>Prophetlabs</title>
        <description>My Blog</description>
        <link>https://prophetlabs.de</link>
        <pubDate>2 March 2022</pubDate>
        <lastBuildDate>2 March 2022</lastBuildDate>
        <ttl>60</ttl>
        <item>
    <title> Faking Local Instances with unsafeCoerce Dict</title>
    <link>http://prophetlabs.de/posts/unsafeCoerceDict.html</link>
    <guid isPremaLink="true">http://prophetlabs.de/posts/unsafeCoerceDict.html</guid>
    <pubDate>2022-3-18</pubDate>
    <description>



&lt;p&gt;When you first learned about Haskell’s &lt;code&gt;Monoid&lt;/code&gt; typeclass, you were probably quite surprised to find out that there is no instance for &lt;code&gt;Monoid Int&lt;/code&gt; in &lt;code&gt;base&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;After all, &lt;code&gt;(+)&lt;/code&gt; is an associative binary operation, and &lt;code&gt;0&lt;/code&gt; acts as a unit element.&lt;/p&gt;
&lt;div class="sourceCode" id="cb1"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb1-1"&gt;&lt;a href="#cb1-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-2"&gt;&lt;a href="#cb1-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;+&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb1-3"&gt;&lt;a href="#cb1-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb1-4"&gt;&lt;a href="#cb1-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The reason, as you will have learned is that this is not the &lt;em&gt;only&lt;/em&gt; possible instance for &lt;code&gt;Monoid Int&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;The following instance is, in fact, just as valid.&lt;/p&gt;
&lt;div class="sourceCode" id="cb2"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb2-1"&gt;&lt;a href="#cb2-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-2"&gt;&lt;a href="#cb2-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;*&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb2-3"&gt;&lt;a href="#cb2-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb2-4"&gt;&lt;a href="#cb2-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;You might also be aware, that the way to work around this is to declare newtype wrappers and to wrap and unwrap all &lt;code&gt;Int&lt;/code&gt;s every time the Monoid instance is needed.&lt;/p&gt;
&lt;div class="sourceCode" id="cb3"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb3-1"&gt;&lt;a href="#cb3-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; {&lt;span class="ot"&gt;getSum ::&lt;/span&gt; a}&lt;/span&gt;
&lt;span id="cb3-2"&gt;&lt;a href="#cb3-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; {&lt;span class="ot"&gt;getProduct ::&lt;/span&gt; a}&lt;/span&gt;
&lt;span id="cb3-3"&gt;&lt;a href="#cb3-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-4"&gt;&lt;a href="#cb3-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-5"&gt;&lt;a href="#cb3-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="dt"&gt;Sum&lt;/span&gt; x) &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; y) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; (x &lt;span class="op"&gt;+&lt;/span&gt; y)&lt;/span&gt;
&lt;span id="cb3-6"&gt;&lt;a href="#cb3-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-7"&gt;&lt;a href="#cb3-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;0&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-8"&gt;&lt;a href="#cb3-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-9"&gt;&lt;a href="#cb3-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-10"&gt;&lt;a href="#cb3-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    (&lt;span class="dt"&gt;Product&lt;/span&gt; x) &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; y) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; (x &lt;span class="op"&gt;*&lt;/span&gt; y)&lt;/span&gt;
&lt;span id="cb3-11"&gt;&lt;a href="#cb3-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; (&lt;span class="dt"&gt;Num&lt;/span&gt; a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Product&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-12"&gt;&lt;a href="#cb3-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;mempty&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Product&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-13"&gt;&lt;a href="#cb3-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb3-14"&gt;&lt;a href="#cb3-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;foldMap&lt;/span&gt; [(&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;)&lt;span class="op"&gt;..&lt;/span&gt;(&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;10&lt;/span&gt;)] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb3-15"&gt;&lt;a href="#cb3-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;There is a bit of boilerplate involved in defining the newtypes and corresponding instances, but what is hard to swallow is that quite a bit of boilerplate has to be included at &lt;em&gt;every single use site&lt;/em&gt;.&lt;a href="#fn1" class="footnote-ref" id="fnref1" role="doc-noteref"&gt;&lt;sup&gt;1&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;If Haskell had local instances, this would not be an issue since we would not be forced to commit to a single instance and could just tell the compiler the instance we want without having to constantly wrap and unwrap everything.&lt;a href="#fn2" class="footnote-ref" id="fnref2" role="doc-noteref"&gt;&lt;sup&gt;2&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;h2 id="introducing-dict"&gt;Introducing &lt;code&gt;Dict&lt;/code&gt;&lt;/h2&gt;
&lt;p&gt;GHC uses a technique called &lt;em&gt;dictionary passing&lt;/em&gt; to compile typeclass dictionaries. This means that in Core (GHC’s intermediate language), &lt;code&gt;=&gt;&lt;/code&gt; is turned into &lt;code&gt;-&gt;&lt;/code&gt;. In other words, &lt;em&gt;constraints become arguments&lt;/em&gt;, called &lt;em&gt;dictionaries&lt;/em&gt;.&lt;/p&gt;
&lt;p&gt;Why is that useful to know? Well, while there is no way to directly access or construct these dictionaries, we &lt;em&gt;can&lt;/em&gt; reify them with &lt;code&gt;Dict&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb4"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb4-1"&gt;&lt;a href="#cb4-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="ot"&gt;c ::&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb4-2"&gt;&lt;a href="#cb4-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because the constraint &lt;code&gt;c&lt;/code&gt; appears in the type signature of the &lt;code&gt;Dict&lt;/code&gt; constructor, the constructor stores the corresponding dictionary, and whenever it is scrutinized in a pattern match, the constraint is made available.&lt;/p&gt;
&lt;p&gt;Unfortunately, even with &lt;code&gt;Dict&lt;/code&gt;, there is no way to construct a dictionary without defining an instance first.&lt;/p&gt;
&lt;p&gt;The only way to construct a ‘local’ instance then is to define an instance for a newtype wrapper, but if we create a Dict from that instance, we cannot use the newtype &lt;code&gt;Dict&lt;/code&gt; for our original type, because &lt;code&gt;Dict (Monoid Int)&lt;/code&gt; and &lt;code&gt;Dict (Monoid (Sum Int))&lt;/code&gt; are entirely separate types to the typechecker.&lt;/p&gt;
&lt;p&gt;We hit quite the wall there. We know we could use the Dict for our newtype, and we know it would be safe&lt;a href="#fn3" class="footnote-ref" id="fnref3" role="doc-noteref"&gt;&lt;sup&gt;3&lt;/sup&gt;&lt;/a&gt; because newtypes are erased at runtime, but the typechecker doesn’t allow us to use a newtype Dict to get an instance for the original type.&lt;/p&gt;
&lt;p&gt;If there was just some way to bypass the typechecker…&lt;/p&gt;
&lt;h2 id="i-solemnly-swear-i-am-up-to-no-good"&gt;I solemnly swear I am up to no good&lt;/h2&gt;
&lt;p&gt;Luckily for us: there is!&lt;/p&gt;
&lt;p&gt;&lt;code&gt;unsafeCoerce :: forall a b. a -&gt; b&lt;/code&gt; lets us bypass the typechecker by treating a value of &lt;em&gt;any&lt;/em&gt; (lifted) type as a value of &lt;em&gt;any other&lt;/em&gt; (lifted) type.&lt;/p&gt;
&lt;p&gt;This is probably one of the most dangerous, if not &lt;em&gt;the&lt;/em&gt; most dangerous function in GHC’s arsenal. If you’re not careful, you can easily end up with segmentation faults.&lt;/p&gt;
&lt;p&gt;We know what we’re doing though, so let’s try it out!&lt;/p&gt;
&lt;div class="sourceCode" id="cb5"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb5-1"&gt;&lt;a href="#cb5-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;monoidSumDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;))&lt;/span&gt;
&lt;span id="cb5-2"&gt;&lt;a href="#cb5-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;monoidSumDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-3"&gt;&lt;a href="#cb5-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-4"&gt;&lt;a href="#cb5-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;monoidIntDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb5-5"&gt;&lt;a href="#cb5-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;monoidIntDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce monoidSumDict&lt;/span&gt;
&lt;span id="cb5-6"&gt;&lt;a href="#cb5-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb5-7"&gt;&lt;a href="#cb5-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="co"&gt;-- If we didn&#39;t include the type signature, GHC would be confused about the type of number we&#39;re using&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb5-8"&gt;&lt;a href="#cb5-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; monoidIntDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb5-9"&gt;&lt;a href="#cb5-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Perfect! We just created an instance of &lt;code&gt;Monoid Int&lt;/code&gt;, that only exists if we pattern match on &lt;code&gt;monoidIntDict&lt;/code&gt;. This sounds a lot like local instances to me.&lt;/p&gt;
&lt;h2 id="lets-simplify-this"&gt;Let’s simplify this&lt;/h2&gt;
&lt;p&gt;What we have so far is already pretty cool, but having to write out a pattern match every time is a bit inconvenient.&lt;/p&gt;
&lt;p&gt;Fortunately, we can easily factor out the pattern match by turning it into a function.&lt;/p&gt;
&lt;div class="sourceCode" id="cb6"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb6-1"&gt;&lt;a href="#cb6-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb6-2"&gt;&lt;a href="#cb6-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withDict d x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; d &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb6-3"&gt;&lt;a href="#cb6-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb6-4"&gt;&lt;a href="#cb6-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withDict monoidIntDict &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb6-5"&gt;&lt;a href="#cb6-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;That &lt;code&gt;(c =&gt; a)&lt;/code&gt; argument might look a bit strange, but this is exactly what we’re trying to do: Take a value or function with a constraint and remove that constraint by inserting the instance stored in our &lt;code&gt;Dict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;We can do even better. The only way to construct one of our ‘local’ Dicts is to create a &lt;code&gt;Dict&lt;/code&gt; for a newtype and cast that to a &lt;code&gt;Dict&lt;/code&gt; for the original type using &lt;code&gt;unsafeCoerce&lt;/code&gt;, but users of our library really shouldn’t have to write their own &lt;code&gt;Dict&lt;/code&gt; definition, let alone use &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb7"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb7-1"&gt;&lt;a href="#cb7-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c1 c2 d&lt;span class="op"&gt;.&lt;/span&gt; c1 &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c2 &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb7-2"&gt;&lt;a href="#cb7-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; c2Dict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb7-3"&gt;&lt;a href="#cb7-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-4"&gt;&lt;a href="#cb7-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        c1Dict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c1&lt;/span&gt;
&lt;span id="cb7-5"&gt;&lt;a href="#cb7-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        c1Dict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb7-6"&gt;&lt;a href="#cb7-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        c2Dict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c2&lt;/span&gt;
&lt;span id="cb7-7"&gt;&lt;a href="#cb7-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        c2Dict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce c1Dict &lt;/span&gt;
&lt;span id="cb7-8"&gt;&lt;a href="#cb7-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb7-9"&gt;&lt;a href="#cb7-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; (&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)) &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb7-10"&gt;&lt;a href="#cb7-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now, all that users have to do is supply the right type applications and &lt;code&gt;withLocal&lt;/code&gt; is going to do everything else for them. Nice!&lt;/p&gt;
&lt;h2 id="hey-google-whats-a-segfault"&gt;Hey Google, what’s a segfault?&lt;/h2&gt;
&lt;div class="sourceCode" id="cb8"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb8-1"&gt;&lt;a href="#cb8-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Eq&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Num&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;$&lt;/span&gt; (&lt;span class="op"&gt;-&lt;/span&gt;&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;2&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb8-2"&gt;&lt;a href="#cb8-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;fish&lt;span class="op"&gt;:&lt;/span&gt; &lt;span class="dt"&gt;Job&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;, &#39;ghci unsafeCoerceDict&lt;span class="op"&gt;.&lt;/span&gt;hs&#39; terminated by signal &lt;span class="dt"&gt;SIGSEGV&lt;/span&gt; (&lt;span class="dt"&gt;Address&lt;/span&gt; boundary &lt;span class="fu"&gt;error&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh no&lt;a href="#fn4" class="footnote-ref" id="fnref4" role="doc-noteref"&gt;&lt;sup&gt;4&lt;/sup&gt;&lt;/a&gt;…&lt;/p&gt;
&lt;p&gt;We just used &lt;code&gt;unsafeCoerce&lt;/code&gt; to cast a &lt;code&gt;Dict (Eq Bool)&lt;/code&gt; to a &lt;code&gt;Dict (Num Int)&lt;/code&gt;. We really shouldn’t be able to do this.&lt;/p&gt;
&lt;p&gt;The issue here is that &lt;code&gt;withLocal&lt;/code&gt; places no constraints on the — well — &lt;em&gt;constraints&lt;/em&gt; (&lt;code&gt;c1&lt;/code&gt; and &lt;code&gt;c2&lt;/code&gt;). In reality, we need both constraints to contain the same typeclass and to only differ in the &lt;em&gt;argument&lt;/em&gt; to that class.&lt;/p&gt;
&lt;p&gt;Let’s do that.&lt;/p&gt;
&lt;div class="sourceCode" id="cb9"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb9-1"&gt;&lt;a href="#cb9-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c a b d&lt;span class="op"&gt;.&lt;/span&gt; (c a) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c b &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb9-2"&gt;&lt;a href="#cb9-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cbDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb9-3"&gt;&lt;a href="#cb9-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-4"&gt;&lt;a href="#cb9-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        caDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c a)&lt;/span&gt;
&lt;span id="cb9-5"&gt;&lt;a href="#cb9-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        caDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb9-6"&gt;&lt;a href="#cb9-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        cbDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c b)&lt;/span&gt;
&lt;span id="cb9-7"&gt;&lt;a href="#cb9-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        cbDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce caDict &lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we did not change anything about the implementation. We just constrained its type signature.&lt;/p&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;withLocal&lt;/code&gt; can still segfault because there are still no constraints on &lt;code&gt;a&lt;/code&gt; and &lt;code&gt;b&lt;/code&gt;. We could, for instance, still try to convert a &lt;code&gt;Monoid String&lt;/code&gt; to a &lt;code&gt;Monoid Int&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="why-did-this-even-work-before"&gt;Why did this even work before?&lt;/h2&gt;
&lt;p&gt;The reason why this function is safe on &lt;code&gt;Sum Int&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; is that &lt;code&gt;Sum Int&lt;/code&gt; is just a newtype wrapper over &lt;code&gt;Int&lt;/code&gt;, and newtypes are completely erased at runtime. So a function of type &lt;code&gt;Sum Int -&gt; b&lt;/code&gt; really becomes a function of type &lt;code&gt;Int -&gt; b&lt;/code&gt; at runtime.&lt;/p&gt;
&lt;p&gt;Thus we can safely&lt;a href="#fn5" class="footnote-ref" id="fnref5" role="doc-noteref"&gt;&lt;sup&gt;5&lt;/sup&gt;&lt;/a&gt; cast it to &lt;code&gt;Int -&gt; b&lt;/code&gt; using &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;String&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt; don’t have the same runtime representation, so we cannot safely cast &lt;code&gt;Dict (Monoid String)&lt;/code&gt; to &lt;code&gt;Dict (Monoid Int)&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Fortunately for us, Haskell does actually provide a way to constrain a function to types with the same runtime representation: &lt;code&gt;Coercible&lt;/code&gt;!&lt;/p&gt;
&lt;p&gt;If we adjust our function to include a &lt;code&gt;Coercible a b&lt;/code&gt; constraint, we finally end up with a safe implementation that doesn’t segfault!&lt;/p&gt;
&lt;div class="sourceCode" id="cb10"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb10-1"&gt;&lt;a href="#cb10-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withLocal ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c a b d&lt;span class="op"&gt;.&lt;/span&gt; (c a, &lt;span class="dt"&gt;Coercible&lt;/span&gt; a b) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; (c b &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb10-2"&gt;&lt;a href="#cb10-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withLocal x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cbDict &lt;span class="kw"&gt;of&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb10-3"&gt;&lt;a href="#cb10-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-4"&gt;&lt;a href="#cb10-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        caDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c a)&lt;/span&gt;
&lt;span id="cb10-5"&gt;&lt;a href="#cb10-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        caDict &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb10-6"&gt;&lt;a href="#cb10-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        cbDict ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; (c b)&lt;/span&gt;
&lt;span id="cb10-7"&gt;&lt;a href="#cb10-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        cbDict &lt;span class="ot"&gt;=&lt;/span&gt; unsafeCoerce caDict &lt;/span&gt;
&lt;span id="cb10-8"&gt;&lt;a href="#cb10-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb10-9"&gt;&lt;a href="#cb10-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;λ&lt;span class="op"&gt;&gt;&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Monoid&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Sum&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; fold [&lt;span class="dv"&gt;1&lt;/span&gt;&lt;span class="op"&gt;..&lt;/span&gt;&lt;span class="dv"&gt;10&lt;/span&gt;] &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb10-10"&gt;&lt;a href="#cb10-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="dv"&gt;60&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that we still had to use &lt;code&gt;unsafeCoerce&lt;/code&gt; instead of &lt;code&gt;coerce&lt;/code&gt;. Just because &lt;code&gt;a&lt;/code&gt; can be coerced to &lt;code&gt;b&lt;/code&gt;, doesn’t mean GHC will allow you to cast &lt;code&gt;Dict (c a)&lt;/code&gt; to &lt;code&gt;Dict (c b)&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="expanding"&gt;Expanding&lt;/h2&gt;
&lt;p&gt;What we have so far is already pretty cool, but we can do even better.&lt;/p&gt;
&lt;p&gt;So far, all our local instances were limited by us having to write an instance for a newtype wrapper and so our instances could not include entirely arbitrary functions.&lt;/p&gt;
&lt;p&gt;We couldn’t, for example, declare a local function depending on a local variable and use that in an instance, because instances have to be written at the top level and therefore can’t include local variables.&lt;/p&gt;
&lt;p&gt;Fortunately, by selling a bit more of our soul to the type checker, we can work around this limitation!&lt;/p&gt;
&lt;p&gt;At runtime, dictionaries (not &lt;code&gt;Dict&lt;/code&gt;s) are really just regular data types, so there is no reason, why we shouldn’t be able to fake them with &lt;code&gt;unsafeCoerce&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Note, that &lt;code&gt;Dict&lt;/code&gt; actually stores the runtime dictionary as a lifted field, so if we want to coerce to &lt;code&gt;Dict&lt;/code&gt;, we need to add a layer of indirection.&lt;/p&gt;
&lt;div class="sourceCode" id="cb11"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb11-1"&gt;&lt;a href="#cb11-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;FakeDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FakeDict&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now for the runtime dictionary, let’s look at the definition of the &lt;code&gt;Eq&lt;/code&gt; typeclass.&lt;/p&gt;
&lt;div class="sourceCode" id="cb12"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb12-1"&gt;&lt;a href="#cb12-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Eq&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-2"&gt;&lt;a href="#cb12-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;  (==) ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-3"&gt;&lt;a href="#cb12-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;  (/=) ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb12-4"&gt;&lt;a href="#cb12-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;  &lt;span class="ot"&gt;{-# MINIMAL (==) | (/=) #-}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Eq&lt;/code&gt; has two methods &lt;code&gt;(==)&lt;/code&gt; and &lt;code&gt;(/=)&lt;/code&gt;, so our datatype also has to have two fields with matching types.&lt;/p&gt;
&lt;div class="sourceCode" id="cb13"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb13-1"&gt;&lt;a href="#cb13-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;EqDict&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;EqDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb13-2"&gt;&lt;a href="#cb13-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        _eq  ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-3"&gt;&lt;a href="#cb13-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _neq ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Bool&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb13-4"&gt;&lt;a href="#cb13-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    }&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Now we need a function to make &lt;code&gt;unsafeCoere&lt;/code&gt; a little less unsafe.&lt;/p&gt;
&lt;div class="sourceCode" id="cb14"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb14-1"&gt;&lt;a href="#cb14-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withFakeDictUnsafe ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; c d a&lt;span class="op"&gt;.&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb14-2"&gt;&lt;a href="#cb14-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDictUnsafe d x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; unsafeCoerce (&lt;span class="dt"&gt;FakeDict&lt;/span&gt; d)&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Dict&lt;/span&gt; c &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb14-3"&gt;&lt;a href="#cb14-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;Dict&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; x&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This already works for simple classes like &lt;code&gt;Eq&lt;/code&gt;, but right now we can’t handle classes with superclasses like &lt;code&gt;Monoid&lt;/code&gt;, because we have no way of storing the superclass dictionary in our fake dictionary.&lt;/p&gt;
&lt;p&gt;In order to include the dictionary, we have to expand our &lt;code&gt;MonoidDict&lt;/code&gt; to a GADT.&lt;/p&gt;
&lt;div class="sourceCode" id="cb15"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb15-1"&gt;&lt;a href="#cb15-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;data&lt;/span&gt; &lt;span class="dt"&gt;MonoidDict&lt;/span&gt; a &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb15-2"&gt;&lt;a href="#cb15-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="dt"&gt;MonoidDict&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb15-3"&gt;&lt;a href="#cb15-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;        _mempty  ::&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb15-4"&gt;&lt;a href="#cb15-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _mappend ::&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb15-5"&gt;&lt;a href="#cb15-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,&lt;span class="ot"&gt;   _mconcat ::&lt;/span&gt; [a] &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;/span&gt;
&lt;span id="cb15-6"&gt;&lt;a href="#cb15-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    } &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;MonoidDict&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;And… that’s it!&lt;/p&gt;
&lt;p&gt;We can now actually write useful functions that we couldn’t just emulate by wrapping everything in a newtype.&lt;/p&gt;
&lt;p&gt;As an example, let’s consider a function that (locally) implements a &lt;code&gt;Monoid&lt;/code&gt; instance for a type, which only implements &lt;code&gt;Semigroup&lt;/code&gt;, based on a provided default argument for &lt;code&gt;mempty&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb16"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb16-1"&gt;&lt;a href="#cb16-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withSemigroupAsMonoid ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; a b&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;Semigroup&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (&lt;span class="dt"&gt;Monoid&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; b) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; b&lt;/span&gt;
&lt;span id="cb16-2"&gt;&lt;a href="#cb16-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withSemigroupAsMonoid d &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDictUnsafe &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;Monoid&lt;/span&gt; a) (&lt;span class="dt"&gt;MonoidDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb16-3"&gt;&lt;a href="#cb16-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _mempty  &lt;span class="ot"&gt;=&lt;/span&gt; d&lt;/span&gt;
&lt;span id="cb16-4"&gt;&lt;a href="#cb16-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,   _mappend &lt;span class="ot"&gt;=&lt;/span&gt; (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;)&lt;/span&gt;
&lt;span id="cb16-5"&gt;&lt;a href="#cb16-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    ,   _mconcat &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldr&lt;/span&gt; (&lt;span class="op"&gt;&lt;&gt;&lt;/span&gt;) d&lt;/span&gt;
&lt;span id="cb16-6"&gt;&lt;a href="#cb16-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We couldn’t use a newtype instance, since &lt;code&gt;withSemigroupAsMonoid&lt;/code&gt; uses the function parameter &lt;code&gt;d&lt;/code&gt; in its instance definition.&lt;/p&gt;
&lt;h2 id="template-haskell"&gt;Template Haskell&lt;/h2&gt;
&lt;p&gt;Writing all these Dict types by hand is not just annoying, but also quite dangerous because they are not automatically kept in sync with the corresponding type classes, so if one of those changes and we forget to update the Dict, the types are not actually compatible anymore.&lt;/p&gt;
&lt;p&gt;We can use some TemplateHaskell to automate the process and (hopefully) avoid further segfaults.&lt;/p&gt;
&lt;p&gt;My experience with TemplateHaskell is pretty limited, so I’m not going to pretend like this is a great implementation.&lt;a href="#fn6" class="footnote-ref" id="fnref6" role="doc-noteref"&gt;&lt;sup&gt;6&lt;/sup&gt;&lt;/a&gt;&lt;/p&gt;
&lt;div class="sourceCode" id="cb17"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb17-1"&gt;&lt;a href="#cb17-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;makeDict ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; [&lt;span class="dt"&gt;Dec&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb17-2"&gt;&lt;a href="#cb17-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict cname &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-3"&gt;&lt;a href="#cb17-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    reify cname &lt;span class="op"&gt;&gt;&gt;=&lt;/span&gt; \&lt;span class="kw"&gt;case&lt;/span&gt; &lt;span class="co"&gt;-- (1)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-4"&gt;&lt;a href="#cb17-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        &lt;span class="dt"&gt;ClassI&lt;/span&gt; cdec is &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; cdec &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-5"&gt;&lt;a href="#cb17-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            &lt;span class="dt"&gt;ClassD&lt;/span&gt; cxt cname tvs _ meths &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;pure&lt;/span&gt; [&lt;/span&gt;
&lt;span id="cb17-6"&gt;&lt;a href="#cb17-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        dataCon [] dname tvs &lt;span class="dt"&gt;Nothing&lt;/span&gt; [&lt;span class="dt"&gt;ForallC&lt;/span&gt; (&lt;span class="fu"&gt;map&lt;/span&gt; (addSpecificity &lt;span class="dt"&gt;SpecifiedSpec&lt;/span&gt;) tvs) cxt &lt;/span&gt;
&lt;span id="cb17-7"&gt;&lt;a href="#cb17-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                            &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="dt"&gt;RecGadtC&lt;/span&gt; [dname] (&lt;span class="fu"&gt;map&lt;/span&gt; methodToVarBangType meths) appliedFakeType] [] &lt;span class="co"&gt;-- (2)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-8"&gt;&lt;a href="#cb17-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    ]&lt;/span&gt;
&lt;span id="cb17-9"&gt;&lt;a href="#cb17-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-10"&gt;&lt;a href="#cb17-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    dataCon &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;case&lt;/span&gt; (meths, cxt) &lt;span class="kw"&gt;of&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-11"&gt;&lt;a href="#cb17-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        ([_], []) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; \cxt name tvs k [cs] ds &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;NewtypeD&lt;/span&gt; cxt name tvs k cs ds &lt;span class="co"&gt;-- (4)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-12"&gt;&lt;a href="#cb17-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                        _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;DataD&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-13"&gt;&lt;a href="#cb17-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    dname &lt;span class="ot"&gt;=&lt;/span&gt; mkName &lt;span class="op"&gt;$&lt;/span&gt; nameBase cname &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;Dict&quot;&lt;/span&gt; &lt;span class="co"&gt;-- (3)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb17-14"&gt;&lt;a href="#cb17-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    &lt;/span&gt;
&lt;span id="cb17-15"&gt;&lt;a href="#cb17-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    methodToVarBangType (&lt;span class="dt"&gt;SigD&lt;/span&gt; n t) &lt;span class="ot"&gt;=&lt;/span&gt; (mkName (&lt;span class="st"&gt;&quot;_&quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; nameBase n), &lt;span class="dt"&gt;Bang&lt;/span&gt; &lt;span class="dt"&gt;SourceNoUnpack&lt;/span&gt; &lt;span class="dt"&gt;NoSourceStrictness&lt;/span&gt;, t)&lt;/span&gt;
&lt;span id="cb17-16"&gt;&lt;a href="#cb17-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    &lt;/span&gt;
&lt;span id="cb17-17"&gt;&lt;a href="#cb17-17" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    appliedFakeType  &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldl&lt;/span&gt; &lt;span class="dt"&gt;AppT&lt;/span&gt; (&lt;span class="dt"&gt;ConT&lt;/span&gt; dname) (&lt;span class="fu"&gt;map&lt;/span&gt; (&lt;span class="dt"&gt;VarT&lt;/span&gt; &lt;span class="op"&gt;.&lt;/span&gt; tyVarName) tvs)&lt;/span&gt;
&lt;span id="cb17-18"&gt;&lt;a href="#cb17-18" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    appliedClassType &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;foldl&lt;/span&gt; &lt;span class="dt"&gt;AppT&lt;/span&gt; (&lt;span class="dt"&gt;ConT&lt;/span&gt; cname) (&lt;span class="fu"&gt;map&lt;/span&gt; (&lt;span class="dt"&gt;VarT&lt;/span&gt; &lt;span class="op"&gt;.&lt;/span&gt; tyVarName) tvs)&lt;/span&gt;
&lt;span id="cb17-19"&gt;&lt;a href="#cb17-19" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb17-20"&gt;&lt;a href="#cb17-20" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    addSpecificity s (&lt;span class="dt"&gt;PlainTV&lt;/span&gt; n _) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;PlainTV&lt;/span&gt; n s&lt;/span&gt;
&lt;span id="cb17-21"&gt;&lt;a href="#cb17-21" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    addSpecificity s (&lt;span class="dt"&gt;KindedTV&lt;/span&gt; n _ k) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;KindedTV&lt;/span&gt; n s k&lt;/span&gt;
&lt;span id="cb17-22"&gt;&lt;a href="#cb17-22" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb17-23"&gt;&lt;a href="#cb17-23" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    tyVarName (&lt;span class="dt"&gt;PlainTV&lt;/span&gt; n _) &lt;span class="ot"&gt;=&lt;/span&gt; n&lt;/span&gt;
&lt;span id="cb17-24"&gt;&lt;a href="#cb17-24" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;                    tyVarName (&lt;span class="dt"&gt;KindedTV&lt;/span&gt; n _ _) &lt;span class="ot"&gt;=&lt;/span&gt; n&lt;/span&gt;
&lt;span id="cb17-25"&gt;&lt;a href="#cb17-25" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;            _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;fail&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&quot;Not a class: &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; cname&lt;/span&gt;
&lt;span id="cb17-26"&gt;&lt;a href="#cb17-26" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _ &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="fu"&gt;fail&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="st"&gt;&quot;Not a class: &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; cname&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The important steps are these:&lt;/p&gt;
&lt;ol type="1"&gt;
&lt;li&gt;We get the class definition using &lt;code&gt;reify&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;We can use that definition to construct a record GADT (&lt;code&gt;RecGadtC&lt;/code&gt;) with one field for every class method.&lt;/li&gt;
&lt;li&gt;The new GADT is called &lt;code&gt;&lt;ClassName&gt;Dict&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;If there is only a single method and no superclass, we construct a newtype instead. Note that this step is not just an optimization, but absolutely crucial, since a &lt;code&gt;data&lt;/code&gt; constructor has one more level of indirection than a newtype, and confusing the two would lead to a segfault.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;We actually get another benefit from generating our instance. Since we know, that using &lt;code&gt;withFakeDictUnsafe&lt;/code&gt; with our generated &lt;code&gt;MonoidDict&lt;/code&gt; is safe, we can use a (non-exported) type class and a function &lt;code&gt;withFakeDict&lt;/code&gt; to constrain arguments to &lt;em&gt;safe&lt;/em&gt; (i.e. generated) dictionaries.&lt;/p&gt;
&lt;div class="sourceCode" id="cb18"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb18-1"&gt;&lt;a href="#cb18-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;FakeDictFor&lt;/span&gt; (&lt;span class="ot"&gt;c ::&lt;/span&gt; &lt;span class="dt"&gt;Constraint&lt;/span&gt;) (&lt;span class="ot"&gt;d ::&lt;/span&gt; &lt;span class="dt"&gt;Type&lt;/span&gt;) &lt;span class="op"&gt;|&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; c&lt;/span&gt;
&lt;span id="cb18-2"&gt;&lt;a href="#cb18-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb18-3"&gt;&lt;a href="#cb18-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;withFakeDict ::&lt;/span&gt; &lt;span class="kw"&gt;forall&lt;/span&gt; d c a&lt;span class="op"&gt;.&lt;/span&gt; &lt;span class="dt"&gt;FakeDictFor&lt;/span&gt; c d &lt;span class="ot"&gt;=&gt;&lt;/span&gt; d &lt;span class="ot"&gt;-&gt;&lt;/span&gt; (c &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb18-4"&gt;&lt;a href="#cb18-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDict &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDictUnsafe&lt;/span&gt;
&lt;span id="cb18-5"&gt;&lt;a href="#cb18-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb18-6"&gt;&lt;a href="#cb18-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;makeDict ::&lt;/span&gt; &lt;span class="dt"&gt;Name&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Q&lt;/span&gt; [&lt;span class="dt"&gt;Dec&lt;/span&gt;]&lt;/span&gt;
&lt;span id="cb18-7"&gt;&lt;a href="#cb18-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict cname &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="kw"&gt;do&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-8"&gt;&lt;a href="#cb18-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;{- ... -}&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb18-9"&gt;&lt;a href="#cb18-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    [d|instance FakeDictFor $(pure appliedClassType) $(pure appliedFakeType)|]&lt;/span&gt;
&lt;span id="cb18-10"&gt;&lt;a href="#cb18-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="co"&gt;{- ... -}&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h2 id="incoherence"&gt;Incoherence&lt;/h2&gt;
&lt;p&gt;Unfortunately, both &lt;code&gt;withLocal&lt;/code&gt; and &lt;code&gt;withFakeDictUnsafe&lt;/code&gt; have a pretty serious flaw. Usually, whenever we use a typeclass method in Haskell, there are essentially two possibilities: either &lt;em&gt;no&lt;/em&gt; instance exists or there is &lt;em&gt;exactly one&lt;/em&gt; and the compiler picks that one. This is called &lt;em&gt;Coherence&lt;/em&gt; and is also the reason why all in-scope typeclass instances are always exported from a module.&lt;/p&gt;
&lt;p&gt;The issue with our functions is that in case there is already an instance for the typeclass, they introduce a second instance and break the compiler’s Coherence assumption.&lt;/p&gt;
&lt;p&gt;As an example, let’s say we want to introduce a local instance for &lt;code&gt;Show Int&lt;/code&gt;. If we do this, using &lt;code&gt;withLocal&lt;/code&gt;&lt;a href="#fn7" class="footnote-ref" id="fnref7" role="doc-noteref"&gt;&lt;sup&gt;7&lt;/sup&gt;&lt;/a&gt;, which instance is the compiler going to pick? Let’s find out!&lt;/p&gt;
&lt;div class="sourceCode" id="cb19"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb19-1"&gt;&lt;a href="#cb19-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;newtype&lt;/span&gt; &lt;span class="dt"&gt;FancyShow&lt;/span&gt; a &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dt"&gt;FancyShow&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb19-2"&gt;&lt;a href="#cb19-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;instance&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; a &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Show&lt;/span&gt; (&lt;span class="dt"&gt;FancyShow&lt;/span&gt; a) &lt;span class="kw"&gt;where&lt;/span&gt; &lt;/span&gt;
&lt;span id="cb19-3"&gt;&lt;a href="#cb19-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    &lt;span class="fu"&gt;show&lt;/span&gt; (&lt;span class="dt"&gt;FancyShow&lt;/span&gt; x) &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="st"&gt;&quot;⭐&quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; x &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="st"&gt;&quot;⭐&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb19-4"&gt;&lt;a href="#cb19-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb19-5"&gt;&lt;a href="#cb19-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;main &lt;span class="ot"&gt;=&lt;/span&gt; withLocal &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Show&lt;/span&gt; &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;FancyShow&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="dt"&gt;Int&lt;/span&gt; &lt;span class="op"&gt;$&lt;/span&gt; &lt;span class="fu"&gt;print&lt;/span&gt; (&lt;span class="dv"&gt;5&lt;/span&gt;&lt;span class="ot"&gt; ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;)&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;div class="sourceCode" id="cb20"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb20-1"&gt;&lt;a href="#cb20-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc unsafeCoerceDict.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./unsafeCoerceDict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-2"&gt;&lt;a href="#cb20-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;unsafeCoerceDict.hs,&lt;/span&gt; unsafeCoerceDict.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb20-3"&gt;&lt;a href="#cb20-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; unsafeCoerceDict ...&lt;/span&gt;
&lt;span id="cb20-4"&gt;&lt;a href="#cb20-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;⭐5⭐&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nice! It seems like we can override instances using &lt;code&gt;withLocal&lt;/code&gt;. Let’s try that with optimizations&lt;/p&gt;
&lt;div class="sourceCode" id="cb21"&gt;&lt;pre class="sourceCode bash"&gt;&lt;code class="sourceCode bash"&gt;&lt;span id="cb21-1"&gt;&lt;a href="#cb21-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;$&lt;/span&gt; ghc &lt;span class="at"&gt;-O&lt;/span&gt; unsafeCoerceDict.hs &lt;span class="kw"&gt;&amp;&amp;&lt;/span&gt; &lt;span class="ex"&gt;./unsafeCoerceDict&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-2"&gt;&lt;a href="#cb21-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;[1&lt;/span&gt; of 1] Compiling Main             &lt;span class="er"&gt;(&lt;/span&gt; &lt;span class="ex"&gt;unsafeCoerceDict.hs,&lt;/span&gt; unsafeCoerceDict.o &lt;span class="kw"&gt;)&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb21-3"&gt;&lt;a href="#cb21-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;Linking&lt;/span&gt; unsafeCoerceDict ...&lt;/span&gt;
&lt;span id="cb21-4"&gt;&lt;a href="#cb21-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ex"&gt;5&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Oh no… optimizations can change the semantics of our program by picking the original instance, that we tried to override. We really don’t want that.&lt;/p&gt;
&lt;p&gt;To make matters worse, there is no way to prevent incoherent usage without having to include Template Haskell at call sites, since there is no way to write a type like &lt;code&gt;Not (Eq a) =&gt; (Eq a =&gt; b) -&gt; b&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;It’s not that bad though. As long as we make sure to never try to override existing instances, we are safe.&lt;/p&gt;
&lt;h2 id="implicitparams"&gt;ImplicitParams&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;withFakeDict&lt;/code&gt; might remind you of a different Haskell feature, namely &lt;code&gt;ImplicitParams&lt;/code&gt;. And indeed, we can directly interoperate with &lt;code&gt;ImplicitParams&lt;/code&gt; using &lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;An implicit parameter constraint like&lt;/p&gt;
&lt;div class="sourceCode" id="cb22"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb22-1"&gt;&lt;a href="#cb22-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="op"&gt;?&lt;/span&gt;&lt;span class="ot"&gt;x ::&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb22-2"&gt;&lt;a href="#cb22-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;x &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;is really just syntactic sugar for&lt;/p&gt;
&lt;div class="sourceCode" id="cb23"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb23-1"&gt;&lt;a href="#cb23-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; (&lt;span class="dt"&gt;IP&lt;/span&gt; &lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) &lt;span class="ot"&gt;=&gt;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb23-2"&gt;&lt;a href="#cb23-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f &lt;span class="ot"&gt;=&lt;/span&gt; ip &lt;span class="op"&gt;@&lt;/span&gt;&lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="op"&gt;+&lt;/span&gt; &lt;span class="dv"&gt;1&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;where IP is a regular type class defined in &lt;code&gt;GHC.Classes&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;What’s really cool about this is that we can actually define an &lt;code&gt;IP&lt;/code&gt; constraint using &lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;So instead of&lt;/p&gt;
&lt;div class="sourceCode" id="cb24"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb24-1"&gt;&lt;a href="#cb24-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;let&lt;/span&gt; &lt;span class="op"&gt;?&lt;/span&gt;x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt; &lt;span class="kw"&gt;in&lt;/span&gt; f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;we can write&lt;/p&gt;
&lt;div class="sourceCode" id="cb25"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb25-1"&gt;&lt;a href="#cb25-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;withFakeDict &lt;span class="op"&gt;@&lt;/span&gt;(&lt;span class="dt"&gt;IPDict&lt;/span&gt; &lt;span class="st"&gt;&quot;x&quot;&lt;/span&gt; &lt;span class="dt"&gt;Int&lt;/span&gt;) (&lt;span class="dt"&gt;IPDict&lt;/span&gt; {_ip &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="dv"&gt;5&lt;/span&gt;}) f&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;and get the exact same behavior!&lt;/p&gt;
&lt;p&gt;This means that &lt;code&gt;withFakeDict&lt;/code&gt; is strictly more powerful than ImplicitParams, but it also shares ImplicitParams’ &lt;a href="https://chrisdone.com/posts/whats-wrong-with-implicitparams/"&gt;somewhat famous&lt;/a&gt; &lt;a href="https://ghc.gitlab.haskell.org/ghc/doc/users_guide/exts/implicit_parameters.html#implicit-parameters-and-polymorphic-recursion"&gt;issues&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="configurable-trace"&gt;Configurable trace&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;Debug.Trace.trace&lt;/code&gt; can be a very useful function for quick debugging. Want to know what this intermediate expression evaluates to? Just write it to stderr using &lt;code&gt;trace&lt;/code&gt;. Want to know what values this function is called with? You can use trace for that.&lt;/p&gt;
&lt;div class="sourceCode" id="cb26"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb26-1"&gt;&lt;a href="#cb26-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;f ::&lt;/span&gt; &lt;span class="dt"&gt;A&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;B&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-2"&gt;&lt;a href="#cb26-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f x &lt;span class="op"&gt;|&lt;/span&gt; trace (&lt;span class="st"&gt;&quot;x = &quot;&lt;/span&gt; &lt;span class="op"&gt;&lt;&gt;&lt;/span&gt; &lt;span class="fu"&gt;show&lt;/span&gt; x) &lt;span class="dt"&gt;False&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="fu"&gt;error&lt;/span&gt; &lt;span class="st"&gt;&quot;unreachable&quot;&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb26-3"&gt;&lt;a href="#cb26-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;f x &lt;span class="ot"&gt;=&lt;/span&gt; &lt;span class="op"&gt;...&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Unfortunately, &lt;code&gt;trace&lt;/code&gt; is not really suited for slightly more permanent tracing, since there is no way to turn it off or to change the target it writes to.&lt;/p&gt;
&lt;p&gt;If we wanted to improve trace, we would have to somehow pass a configuration without &lt;em&gt;actually&lt;/em&gt; passing it manually to every single function. Sounds a lot like type classes to me!&lt;/p&gt;
&lt;p&gt;Let’s try that. We should also probably use &lt;code&gt;Text&lt;/code&gt; instead of &lt;code&gt;String&lt;/code&gt;, while we’re at it.&lt;/p&gt;
&lt;div class="sourceCode" id="cb27"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb27-1"&gt;&lt;a href="#cb27-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb27-2"&gt;&lt;a href="#cb27-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To make filtering easier, we should probably also accept some kind of trace level. We could just accept an integer, but parameterizing our class over the type of the trace level is more general.&lt;/p&gt;
&lt;div class="sourceCode" id="cb28"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb28-1"&gt;&lt;a href="#cb28-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb28-2"&gt;&lt;a href="#cb28-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Cool. Functions that want to perform logging now need an additional &lt;code&gt;Trace lvl&lt;/code&gt; constraint, that supplies the actual implementation.&lt;/p&gt;
&lt;p&gt;How do we pick the implementation though? If you’ve paid attention so far, the answer should be obvious: We construct a fake dictionary using &lt;code&gt;withFakeDict&lt;/code&gt;.&lt;/p&gt;
&lt;div class="sourceCode" id="cb29"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb29-1"&gt;&lt;a href="#cb29-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-2"&gt;&lt;a href="#cb29-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-3"&gt;&lt;a href="#cb29-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-4"&gt;&lt;a href="#cb29-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict &#39;&lt;span class="dt"&gt;&#39;Trace&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb29-5"&gt;&lt;a href="#cb29-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-6"&gt;&lt;a href="#cb29-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runTraceStderr ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-7"&gt;&lt;a href="#cb29-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runTraceStderr &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;TraceDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb29-8"&gt;&lt;a href="#cb29-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _trace _ &lt;span class="ot"&gt;=&lt;/span&gt; Debug.Trace.trace&lt;/span&gt;
&lt;span id="cb29-9"&gt;&lt;a href="#cb29-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;
&lt;span id="cb29-10"&gt;&lt;a href="#cb29-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb29-11"&gt;&lt;a href="#cb29-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;ignoreTrace ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb29-12"&gt;&lt;a href="#cb29-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ignoreTrace &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;TraceDict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb29-13"&gt;&lt;a href="#cb29-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _trace _ _ x &lt;span class="ot"&gt;=&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb29-14"&gt;&lt;a href="#cb29-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;One issue that might still come up is that someone could theoretically define a top-level instance of &lt;code&gt;Trace lvl&lt;/code&gt;, which would introduce incoherence and completely break our system. To prevent that, we can hide the actual implementation in a class &lt;code&gt;_Trace&lt;/code&gt;, that we don’t actually export. We can then define a type synonym &lt;code&gt;Trace&lt;/code&gt; that we &lt;em&gt;do&lt;/em&gt; export. This way, users of our library can still reference Trace through our type synonym, but cannot define top-level instances since instances cannot be defined for type synonyms of type classes.&lt;/p&gt;
&lt;div class="sourceCode" id="cb30"&gt;&lt;pre class="sourceCode hs"&gt;&lt;code class="sourceCode haskell"&gt;&lt;span id="cb30-1"&gt;&lt;a href="#cb30-1" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;class&lt;/span&gt; _Trace lvl &lt;span class="kw"&gt;where&lt;/span&gt;&lt;/span&gt;
&lt;span id="cb30-2"&gt;&lt;a href="#cb30-2" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;    trace ::&lt;/span&gt; lvl &lt;span class="ot"&gt;-&gt;&lt;/span&gt; &lt;span class="dt"&gt;Text&lt;/span&gt; &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-3"&gt;&lt;a href="#cb30-3" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-4"&gt;&lt;a href="#cb30-4" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;makeDict &#39;&#39;_Trace&lt;/span&gt;
&lt;span id="cb30-5"&gt;&lt;a href="#cb30-5" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-6"&gt;&lt;a href="#cb30-6" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="kw"&gt;type&lt;/span&gt; &lt;span class="dt"&gt;Trace&lt;/span&gt; &lt;span class="ot"&gt;=&lt;/span&gt; _Trace&lt;/span&gt;
&lt;span id="cb30-7"&gt;&lt;a href="#cb30-7" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-8"&gt;&lt;a href="#cb30-8" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;runTraceStderr ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-9"&gt;&lt;a href="#cb30-9" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;runTraceStderr &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;Trace_Dict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb30-10"&gt;&lt;a href="#cb30-10" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;        _trace _ &lt;span class="ot"&gt;=&lt;/span&gt; Debug.Trace.trace&lt;/span&gt;
&lt;span id="cb30-11"&gt;&lt;a href="#cb30-11" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    })&lt;/span&gt;
&lt;span id="cb30-12"&gt;&lt;a href="#cb30-12" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;/span&gt;
&lt;span id="cb30-13"&gt;&lt;a href="#cb30-13" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;&lt;span class="ot"&gt;ignoreTrace ::&lt;/span&gt; (&lt;span class="dt"&gt;Trace&lt;/span&gt; lvl &lt;span class="ot"&gt;=&gt;&lt;/span&gt; a) &lt;span class="ot"&gt;-&gt;&lt;/span&gt; a&lt;/span&gt;
&lt;span id="cb30-14"&gt;&lt;a href="#cb30-14" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;ignoreTrace &lt;span class="ot"&gt;=&lt;/span&gt; withFakeDict (&lt;span class="dt"&gt;Trace_Dict&lt;/span&gt; {&lt;/span&gt;
&lt;span id="cb30-15"&gt;&lt;a href="#cb30-15" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;    _trace _ _ x &lt;span class="ot"&gt;=&lt;/span&gt; x&lt;/span&gt;
&lt;span id="cb30-16"&gt;&lt;a href="#cb30-16" aria-hidden="true" tabindex="-1"&gt;&lt;/a&gt;})&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Nice! We just defined a fairly extensible little tracing library in less than 20 lines of code.&lt;/p&gt;
&lt;p&gt;Here is why this is a good application of fake local instances&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;There is no reason to manually implement the &lt;code&gt;Trace&lt;/code&gt; type class, so we were able to hide it completely and fully prevent incoherence.&lt;/li&gt;
&lt;li&gt;In case we made a mistake or this whole approach is fundamentally flawed and GHC decides to pick the wrong instance, nothing major breaks. (You can never be entirely sure with &lt;code&gt;unsafeCoerce&lt;/code&gt; tricks like this)&lt;/li&gt;
&lt;li&gt;This is really easy to implement, and much less limited than most alternative approaches (Logging monads/effects, global &lt;code&gt;IORef&lt;/code&gt;s, …)&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="conclusion"&gt;Conclusion&lt;/h2&gt;
&lt;p&gt;Now, what did we learn from all of this?&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;It is possible to transfer instances between newtypes.&lt;/li&gt;
&lt;li&gt;This approach can be expanded to allow the inclusion of arbitrary functions as instance methods.&lt;/li&gt;
&lt;li&gt;All segfaults stemming from non-unsafe functions can be avoided and it is possible to generate most boilerplate.&lt;/li&gt;
&lt;li&gt;Incoherence, stemming from multiple instances being available at once, is an issue.&lt;/li&gt;
&lt;li&gt;ImplicitParams can be emulated with local instances.&lt;/li&gt;
&lt;li&gt;A tiny extensible tracing library is a pretty cool application of local instances.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Does this mean, you should throw all your newtypes out of the window? No.&lt;/p&gt;
&lt;p&gt;Does this mean, you should use the code from this article in production? Probably not. You should really know what you’re doing if you want to use anything in production that is based on &lt;code&gt;unsafeCoerce&lt;/code&gt;. That said, if you want to try this out for yourself, the code is available in a &lt;a href="https://github.com/Innf107/fakedict"&gt;small library on github&lt;/a&gt;, including &lt;code&gt;trace&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Ultimately, I hope that you learned a nice little trick today. You never know when it might come in handy.&lt;/p&gt;
&lt;section class="footnotes" role="doc-endnotes"&gt;
&lt;hr /&gt;
&lt;ol&gt;
&lt;li id="fn1" role="doc-endnote"&gt;&lt;p&gt;In this particular example, most boilerplate could be eliminated by using &lt;code&gt;Sum&lt;/code&gt;’s &lt;code&gt;Num&lt;/code&gt; instance, but in most real scenarios it’s unfortunately not that simple.&lt;a href="#fnref1" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn2" role="doc-endnote"&gt;&lt;p&gt;There are very good reasons why Haskell doesn’t have local instances, but we’ll get to that.&lt;a href="#fnref2" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn3" role="doc-endnote"&gt;&lt;p&gt;Well… we’ll see about that.&lt;a href="#fnref3" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn4" role="doc-endnote"&gt;&lt;p&gt;I told you, unsafeCoerce was dangerous…&lt;a href="#fnref4" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn5" role="doc-endnote"&gt;&lt;p&gt;&lt;em&gt;safe&lt;/em&gt; here just means that it doesn’t segfault. We’ll get to other meanings of safe, don’t worry!&lt;a href="#fnref5" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn6" role="doc-endnote"&gt;&lt;p&gt;Feel free to &lt;a href="https://github.com/Innf107/fakedict/tree/main/src/Fakedict/TH.hs"&gt;submit a pull request&lt;/a&gt; if you would like to write a better implementation&lt;a href="#fnref6" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;li id="fn7" role="doc-endnote"&gt;&lt;p&gt;I did not use &lt;code&gt;withFakeDict&lt;/code&gt; here, since &lt;code&gt;Show&lt;/code&gt; has a few additional methods that we would have had to implement manually&lt;a href="#fnref7" class="footnote-back" role="doc-backlink"&gt;↩︎&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/section&gt;
</description>
</item>
    </channel>
</rss>