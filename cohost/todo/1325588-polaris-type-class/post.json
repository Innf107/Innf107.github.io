{"postId":1325588,"headline":"Polaris' type class instances can close over local variables","publishedAt":"2023-04-12T22:28:29.392Z","state":1,"cws":[],"tags":["polaris","programming","programming languages","functional programming","language dev","PLT"],"blocks":[{"type":"markdown","markdown":{"content":"If you know me, you will know that global coherence of type classes is [something I](https://prophetlabs.de/posts/unsafeCoerceDict.html) [care about](https://prophetlabs.de/posts/coherentIP.html) [a lot](https://prophetlabs.de/posts/insttypes.html)."}},{"type":"markdown","markdown":{"content":"And if you understand that type classes in Polaris are globally coherent, I probably confused you quite a bit with that title. How can type classes be globally coherent and still close over local variables? Well, let's start at the beginning."}},{"type":"markdown","markdown":{"content":"## A quick recap of global coherence"}},{"type":"markdown","markdown":{"content":"Type classes in Polaris are, just like in Haskell, globally coherent. This means that for any type class, there is only ever at most a single type class instance per type. This ensures that all instances with the same type are equal and type class instances behave more like predicates (does `a` implement `Show`?) rather than implicit parameters (give me something of type `Show a`), which can be quite important sometimes."}},{"type":"markdown","markdown":{"content":"The downside is that locally overriding coherent type class instances is, by definition, impossible. Therefore, all type class instances need to be global. "}},{"type":"markdown","markdown":{"content":"An instance that closes over local variables cannot exist, since such an instance would only be valid where the local variables are in scope and type class instances need to be global to maintain global coherence."}},{"type":"markdown","markdown":{"content":"## What does Polaris do differently? Local Types!"}},{"type":"markdown","markdown":{"content":"Polaris supports local types that only exist at a local level. For example, in the following code, `A` only exists inside  `f` and any code that would make it escape its scope results in a type error."}},{"type":"markdown","markdown":{"content":"<div style=\"padding: 1rem; overflow: auto; color: #abb2bf;background-color: #282c34;font-family: 'Fira Code', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Mono', 'monospace', monospace;font-weight: normal;font-size: 18px;line-height: 24px;white-space: pre;\"><div><span style=\"color: #9eaee0;\">let</span><span style=\"color: #abb2bf;\"> f() = {</span></div><div><span style=\"color: #abb2bf;\">    </span><span style=\"color: #9eaee0;\">data</span><span style=\"color: #abb2bf;\"> A = { x : String }</span></div><br><div><span style=\"color: #abb2bf;\">    </span><span style=\"color: #9eaee0;\">let</span><span style=\"color: #abb2bf;\"> a = A({ x = </span><span style=\"color: #98c379;\">\"Ad astra per aspera\"</span><span style=\"color: #abb2bf;\"> })</span></div><div><span style=\"color: #abb2bf;\"><br><div><span style=\"color: #abb2bf;\">    a </span><span style=\"color: #abb2bf;\"></span><span style=\"color: #5c6370;\"># Error: A would escape its scope</span></div><div><span style=\"color: #abb2bf;\">}</span></div></div></div>"}},{"type":"markdown","markdown":{"content":"Now, the reason this is interesting is that the same applies to type classes! Type classes can be defined locally and are unable to escape their scope, just like regular types. And now if a type class is defined locally, instances of that class necessarily need to be defined at the same level as the class, i.e. at a *local* level. You might already see where I'm going with this: If type classes can be defined locally, then all instances of that class are defined at the same level, so any local variables that are in scope at the instance declaration **are also going to be in scope at its usage site!**"}},{"type":"markdown","markdown":{"content":"Therefore, instances can safely close over local variables, as long as the class is defined at the same level!"}},{"type":"markdown","markdown":{"content":"This might not seem all that useful for general purpose type classes like `Show` or `Eq`, but keep in mind that type classes can, especially with [closed type classes](https://cohost.org/prophet/post/1215426-closed-type-classes), be treated as functions from types to terms, which are quite useful for metaprogramming."}},{"type":"markdown","markdown":{"content":"In that case, closing over local variables might prove to be extremely useful!"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/1325588-polaris-type-class"}