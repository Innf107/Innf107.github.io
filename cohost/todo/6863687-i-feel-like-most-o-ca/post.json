{"postId":6863687,"headline":"I feel like most OCaml programmers have a very different idea of what polymorphic variants are meant to do than I do","publishedAt":"2024-07-13T09:12:03.042Z","state":1,"cws":[],"tags":["ocaml","polymorphic variants","types","programming languages"],"blocks":[{"type":"markdown","markdown":{"content":"To me, the entire point of polymorphic variants (and row polymorphic records for that matter) is that they give you very convenient *anonymous* variants.\nFor example, in Polaris I have [this function](https://github.com/Innf107/polaris/blob/e15c69198a5c82044d9bec3a4b9bc090038e1a62/src/types.ml#L108)"}},{"type":"markdown","markdown":{"content":"<div style=\"padding: 1rem; border-radius: 5px; overflow: auto; color: #abb2bf;background-color: #282c34;font-family: 'Fira Code', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Mono', 'monospace', monospace;font-weight: normal;font-size: 16px;line-height: 22px;white-space: pre;\"><div><span style=\"color: #9eaee0;\">val</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #61afef;\">match_instance</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">:</span></div><div><span style=\"color: #abb2bf;\">  t </span><span style=\"color: #9eaee0;\">-&gt;</span></div><div><span style=\"color: #abb2bf;\">  ty list </span><span style=\"color: #9eaee0;\">-&gt;</span></div><div><span style=\"color: #abb2bf;\">  [</span><span style=\"color: #9eaee0;\">&gt;</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #d6a3a3;\">`Found</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">of</span><span style=\"color: #abb2bf;\"> class_instance</span></div><div>   <span style=\"color: #9eaee0;\">|</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #d6a3a3;\">`Missing</span></div><div><span style=\"color: #9eaee0;\">   | </span><span style=\"color: #d6a3a3;\">`Ambiguous</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">of</span><span style=\"color: #abb2bf;\"> class_instance list</span></div><div><span style=\"color: #abb2bf;\">  ]</span></div></div>"}},{"type":"markdown","markdown":{"content":"If I didn't have polymorphic variants I would either need to return a `(class_instance, class_instance list) either option` (ugh) or define a separate nominal variant"}},{"type":"markdown","markdown":{"content":"<div style=\"padding: 1rem; border-radius: 5px; overflow: auto; color: #abb2bf;background-color: #282c34;font-family: 'Fira Code', 'Droid Sans Mono', 'monospace', monospace, 'Droid Sans Mono', 'monospace', monospace;font-weight: normal;font-size: 16px;line-height: 22px;white-space: pre;\"><div><span style=\"color: #9eaee0;\">type</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #61afef;\">instance_lookup_result</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">=</span></div><div><span style=\"color: #abb2bf;\">  </span><span style=\"color: #9eaee0;\">|</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #d6a3a3;\">Found</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">of</span><span style=\"color: #abb2bf;\"> class_instance</span></div><div><span style=\"color: #abb2bf;\">  </span><span style=\"color: #9eaee0;\">|</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #d6a3a3;\">Missing</span></div><div><span style=\"color: #abb2bf;\">  </span><span style=\"color: #9eaee0;\">|</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #d6a3a3;\">Ambiguous</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">of</span><span style=\"color: #abb2bf;\"> class_instance list</span></div><br><div><span style=\"color: #9eaee0;\">val</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #61afef;\">match_instance</span><span style=\"color: #abb2bf;\"> </span><span style=\"color: #9eaee0;\">:</span><span style=\"color: #abb2bf;\"> t </span><span style=\"color: #9eaee0;\">-&gt;</span><span style=\"color: #abb2bf;\"> ty list </span><span style=\"color: #9eaee0;\">-&gt;</span><span style=\"color: #abb2bf;\"> instance_lookup_result</span></div></div>"}},{"type":"markdown","markdown":{"content":"But this is annoying to define and update, clutters docs and means that anyone reading the function definition needs to click through to the type definition to see what it actually returns (arguably a tooling issue but not one I've seen solved anywhere). This is actually one of the few places where polymorphic variants can *improve* error messages because the generated error message will immediately show which constructors were expected rather than an opaque `instance_lookup_result` type!"}},{"type":"markdown","markdown":{"content":"So I hope you can see that I really like polymorphic variants when they're used sensibly like this."}},{"type":"markdown","markdown":{"content":"That said, I can't remember ever seeing other people use them like this in OCaml. Somehow nearly all the OCaml code I see defines type synonyms over polymorphic variants.\nFor example, as far as I can tell, [Dream](https://aantron.github.io/dream/) — a very popular library! — doesn't define a single (non-abstract) nominal type and uses polymorphic variants for everything."}},{"type":"markdown","markdown":{"content":"And... I don't get it. It makes sense for [errors](https://aantron.github.io/dream/#type-standard_status) where row polymorphism acts like a more clunky version of subtyping and lets you define functions with more specific error types and implicitly promote them to more specific generic without cluttering your code with the equivalent of `mapError` everywhere."}},{"type":"markdown","markdown":{"content":"But that reasoning doesn't apply to [methods](https://aantron.github.io/dream/#type-method_) does it?"}},{"type":"markdown","markdown":{"content":"And it's not like this is a harmless difference! OCaml already has the worst error messages out of any language I've used and row polymorphism makes this so much worse.\nEven if you accept that, the combination of polymorphic variants and global inference means that it's so easy to write a function that has a different type than you expect that even the [manual warns against overusing polymorphic variants like this](https://ocaml.org/manual/5.2/polyvariant.html#s%3Apolyvariant-weaknesses) and dream has [explicit type coercions everywhere to make sure the inferred types aren't too generic](https://github.com/aantron/dream/blob/41eaac9afc77fe62b84ca806ce967364665c8eda/src/pure/method.ml#L52)."}},{"type":"markdown","markdown":{"content":"So why would you not just use nominal variants?"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/6863687-i-feel-like-most-o-ca"}