{"postId":1215426,"headline":"Closed Type Classes","publishedAt":"2023-03-22T08:30:50.888Z","state":1,"cws":[],"tags":["programming languages","polaris","haskell","type classes"],"blocks":[{"type":"markdown","markdown":{"content":"You know how in Haskell there are functions? These things that transform values into other values?\nYeah, we have that on the type level as well. These are called  *type families*, and they transform *types* into other *types*."}},{"type":"markdown","markdown":{"content":"The main difference: Type families actually exist in two variants! "}},{"type":"markdown","markdown":{"content":"*Closed* type families are defined by pattern matching, just like regular value-level functions. "}},{"type":"markdown","markdown":{"content":"*Open* type families on the other hand are a bit different. These are declared without definitions and individual instances can be added anywhere the type family is in scope, even across module boundaries."}},{"type":"markdown","markdown":{"content":"But the title of this post doesn't say families, does it? So what does this have to do with type classes?"}},{"type":"markdown","markdown":{"content":"While type classes are usually seen as defining behavior for classes of types, an alternative interpretation is to view them as *functions from types to values*. After all, `Show` is really just a way to go from a type `a` to a function `a -> String`."}},{"type":"markdown","markdown":{"content":"But type classes in Haskell are always open! We can visualize this as a table"}},{"type":"markdown","markdown":{"content":"|                           | Open                  | Closed             |\n|---------------------|-------------------|---------------------|\n| **Value -> Value**   | Open function (not in Haskell) | Function\n| **Type -> Type**      | Open type family | Closed type family |\n| **Type -> Value**     | Type class  | **<span style=\"color: red\">???</span>** |"}},{"type":"markdown","markdown":{"content":"There is no fundamental reason why there shouldn't be anything in that <span style=\"color:red\">???</span> corner!"}},{"type":"markdown","markdown":{"content":"In fact, closed type classes that are able to pattern match on types would avoid quite a few of the drawbacks of globally coherent instances and would dramatically simplify [Type Class Metaprogramming](https://lexi-lambda.github.io/blog/2021/03/25/an-introduction-to-typeclass-metaprogramming/)."}},{"type":"markdown","markdown":{"content":"To take an example from that blog post, let's implement a generalized version of `concat`, that flattens arbitrarily deeply nested lists."}},{"type":"markdown","markdown":{"content":"\n(In Polaris syntax)\n```\ntype ElementOf(a) = {\n    List(List(a)) -> ElementOf(List(a))\n    List(a) -> a\n}"}},{"type":"markdown","markdown":{"content":"class flatten(a) : a -> List(ElementOf(a))\nclass flatten = {\n    [[a]] -> \\list -> flatten(concat(list))\n    [a] -> \\x -> x\n}"}},{"type":"markdown","markdown":{"content":"print(flatten([[[1, 2], [3]]], [[4]]))\n# [1, 2, 3, 4]\n```"}},{"type":"markdown","markdown":{"content":"Note that `flatten` is lowercase because it directly defines a function."}},{"type":"markdown","markdown":{"content":"Compared to the same in Haskell, I think this is pretty nice!"}},{"type":"markdown","markdown":{"content":"```hs\ntype family ElementOf a where\n  ElementOf [[a]] = ElementOf [a]\n  ElementOf [a]   = a"}},{"type":"markdown","markdown":{"content":"class Flatten a where\n  flatten :: a -> [ElementOf a]"}},{"type":"markdown","markdown":{"content":"instance Flatten [a] where\n  flatten x = x"}},{"type":"markdown","markdown":{"content":"instance {-# OVERLAPPING #-} Flatten [a] => Flatten [[a]] where\n  flatten x = flatten (concat x)\n```"}},{"type":"markdown","markdown":{"content":"On the implementation side, this would be implemented exactly like regular type classes. Just the instance selection mechanism would be a bit different. `flatten` would be desugared to something like this:"}},{"type":"markdown","markdown":{"content":"```\ntype FlattenDict(a) = a ->  List(ElementOf(a))"}},{"type":"markdown","markdown":{"content":"let flattenListList : (FlattenDict(List(a))) ->  (List(List(a)) -> List(a))\nlet flattenListList(listADict) = \\list -> listADict(concat(list))"}},{"type":"markdown","markdown":{"content":"let flattenSingleList : List(a) -> List(a)\nlet flattenSingleList(x) = x"}},{"type":"markdown","markdown":{"content":"print(flattenListList(flattenListList(flattenSingleList)))([[[1, 2], [3]]], [[4]]))\n```"}},{"type":"markdown","markdown":{"content":"If you have seen something similar before, or if there is anything dramatically problematic about this that I missed, please let me know :)"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/1215426-closed-type-classes"}