{"postId":3399751,"headline":"I really don't like let generalization","publishedAt":"2023-11-03T19:28:14.202Z","state":1,"cws":[],"tags":["programming languages","types","functional programming","type systems","haskell","ocaml"],"blocks":[{"type":"markdown","markdown":{"content":"I just don't think it's worth it."}},{"type":"markdown","markdown":{"content":"I've written before about how let generalization makes language constructs like GADTs, that don't necessarily have principal types, much harder to use.\nNote that this doesn't only happen if a declaration mentions local variables from an outer scope as described in [Let Should Not Be Generalized](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tldi10-vytiniotis.pdf)!"}},{"type":"markdown","markdown":{"content":"For example, as written, this Haskell code doesn't compile because `test` doesn't have a principal type, but uncommenting the `let _ = x` declaration prevents the type checker from generalizing `test`, which means that, based on the only usage site, its type is inferred to the much more specific `T Bool -> Bool -> Bool`, which compiles just fine."}},{"type":"markdown","markdown":{"content":"<pre tabindex=\"0\" style=\"box-sizing: border-box; padding: 0.75rem; margin: 1.25rem -0.75rem; border-radius: 0px; line-height: 1.5; overflow-x: auto; background: rgb(20, 49, 40); color: rgb(187, 238, 219); color-scheme: dark; scrollbar-color: rgb(187, 238, 219) rgb(6, 36, 28);\"><code><span>data</span> <span style=\"color: rgb(233, 228, 169);\">T</span> <span style=\"color: rgb(49, 165, 133);\">::</span> <span style=\"color: rgb(233, 228, 169);\">Type</span> <span style=\"color: rgb(49, 165, 133);\">-&gt;</span> <span style=\"color: rgb(233, 228, 169);\">Type</span> <span>where</span>\n  <span style=\"color: rgb(233, 228, 169);\">T1</span> <span style=\"color: rgb(49, 165, 133);\">::</span> <span style=\"color: rgb(233, 228, 169);\">Int</span> <span style=\"color: rgb(49, 165, 133);\">-&gt;</span> <span style=\"color: rgb(233, 228, 169);\">T</span> <span style=\"color: rgb(233, 228, 169);\">Bool</span>\n  <span style=\"color: rgb(233, 228, 169);\">T2</span> <span style=\"color: rgb(49, 165, 133);\">::</span> <span style=\"color: rgb(233, 228, 169);\">T</span> <span>a</span>"}},{"type":"markdown","markdown":{"content":"<span>f</span> <span>x</span> <span style=\"color: rgb(49, 165, 133);\">=</span>\n  <span style=\"color: rgb(205, 203, 81);\">let</span> \n    <span>test</span> <span style=\"color: rgb(49, 165, 133);\">(</span><span style=\"color: rgb(233, 228, 169);\">T1</span> <span>n</span><span style=\"color: rgb(49, 165, 133);\">)</span> _ <span style=\"color: rgb(49, 165, 133);\">=</span> <span>n</span> <span style=\"color: rgb(49, 165, 133);\">&gt;</span> <span style=\"color: rgb(255, 209, 255);\">0</span>\n    <span>test</span> <span style=\"color: rgb(233, 228, 169);\">T2</span>     <span>r</span> <span style=\"color: rgb(49, 165, 133);\">=</span> \n      <span style=\"color: rgb(122, 154, 142);\">-- let _ = x in</span>\n      <span>r</span>\n  <span style=\"color: rgb(205, 203, 81);\">in</span>\n  <span>test</span> <span style=\"color: rgb(49, 165, 133);\">(</span><span style=\"color: rgb(233, 228, 169);\">T1</span> <span style=\"color: rgb(255, 209, 255);\">5</span><span style=\"color: rgb(49, 165, 133);\">)</span></code></pre><div style=\"margin: -1.25rem -0.75rem 1.25rem; padding: 0.25rem 0.5rem; font-size: smaller; text-align: right; background: rgb(6, 36, 28); color: rgb(187, 238, 219);\">syntax highlighting by <a href=\"https://codehost.wavebeem.com\" style=\"font-weight: bolder;\">codehost</a></div>"}},{"type":"markdown","markdown":{"content":"## But that's not even the only reason to dislike let generalization!\nEven in extremely simple programs, the tooling experience suffers *a lot* when lets are generalized. \nA pattern I like is defining function arguments to functions like `zipWith` (`List.map2` in OCaml) as a local binding. For example"}},{"type":"markdown","markdown":{"content":"<pre tabindex=\"0\" style=\"box-sizing: border-box; padding: 0.75rem; margin: 1.25rem -0.75rem; border-radius: 0px; line-height: 1.5; overflow-x: auto; background: rgb(20, 49, 40); color: rgb(187, 238, 219); color-scheme: dark; scrollbar-color: rgb(187, 238, 219) rgb(6, 36, 28);\"><code><span style=\"color: rgb(205, 203, 81);\">let</span> <span>doSomething</span> <span>index</span> <span>char</span> <span style=\"color: rgb(49, 165, 133);\">=</span> <span style=\"color: rgb(49, 165, 133);\">...</span> <span style=\"color: rgb(205, 203, 81);\">in</span>"}},{"type":"markdown","markdown":{"content":"<span>zipWith</span> <span>doSomething</span> <span style=\"color: rgb(49, 165, 133);\">[</span><span style=\"color: rgb(255, 209, 255);\">0</span><span style=\"color: rgb(49, 165, 133);\">..</span><span style=\"color: rgb(255, 209, 255);\">10</span><span style=\"color: rgb(49, 165, 133);\">]</span> <span style=\"color: rgb(49, 165, 133);\">[</span><span style=\"color: rgb(255, 167, 246);\">'A'</span><span style=\"color: rgb(49, 165, 133);\">..</span><span style=\"color: rgb(255, 167, 246);\">'Z'</span><span style=\"color: rgb(49, 165, 133);\">]</span></code></pre>"}},{"type":"markdown","markdown":{"content":"Now, what is the type of `char` in this case that shows up when I hover over it in my editor or in error messages it's involved in?"}},{"type":"markdown","markdown":{"content":"<pre tabindex=\"0\" style=\"box-sizing: border-box; padding: 0.75rem; margin: 1.25rem -0.75rem; border-radius: 0px; line-height: 1.5; overflow-x: auto; background: rgb(20, 49, 40); color: rgb(187, 238, 219); color-scheme: dark; scrollbar-color: rgb(187, 238, 219) rgb(6, 36, 28);\"><code><span>a</span></code></pre>"}},{"type":"markdown","markdown":{"content":"Yeah. That's not useful. The type is `Char` at the only usage site, but because `doSomething` is unnecessarily generalized, the compiler cannot *assume* that and instead infers the most general - but *definitely* not most relevant - type."}},{"type":"markdown","markdown":{"content":"## And what do we gain in return?"}},{"type":"markdown","markdown":{"content":"Let generalization lets us avoid writing a type signature for **polymorphic** local declarations, that are used **more than once** and **at different instantiations**."}},{"type":"markdown","markdown":{"content":"I'd rather have better error messages."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/3399751-i-really-don-t-like"}