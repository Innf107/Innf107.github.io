{"postId":848270,"headline":"Rebuild Patterns","publishedAt":"2023-01-15T13:32:50.759Z","state":1,"cws":[],"tags":["polaris","language design","programming languages","language dev","functional programming"],"blocks":[{"type":"markdown","markdown":{"content":"Or-patterns are awesome, but I often run into situations where I cannot use them, so I came up with a solution."}},{"type":"markdown","markdown":{"content":" Or-patterns are very convenient for functions that somehow deconstruct values, e.g. finding all literals in an arithmetic expression\n```\ndata Expr = Literal(Int)\n          | Add(Expr, Expr)\n          | Sub(Expr, Expr) "}},{"type":"markdown","markdown":{"content":"let literals(expr) = match expr {\n    Literal(n) -> [n]\n    Add(expr1, expr2) | Sub(expr1, expr2) ->\n         literals(expr1) ++ literals(expr2)\n}\n``` "}},{"type":"markdown","markdown":{"content":"But it breaks down as soon as a function is meant to rebuild the expression, for example a function that sets all literals to 0\n```\nlet replaceLiterals(expr) = match expr {\n    Literal(n) -> Literal(0)\n    Add(expr1, expr2) | Sub(expr1, expr2) ->\n        ???(replaceLiterals(expr1), replaceLiterals(expr2))\n}\n```\nThe `???` would need to be `Add` in one case and `Sub` in the other, but otherwise these should behave exactly the same!"}},{"type":"markdown","markdown":{"content":"## My solution: rebuild patterns"}},{"type":"markdown","markdown":{"content":"```\nlet replaceLiterals(expr) = match expr {\n    Literal(n) -> Literal(0)\n    Add(expr1, expr2) | Sub(expr1, expr2) rebuild constructor ->\n        constructor(replaceLiterals(expr1), replaceLiterals(expr2))\n}\n```"}},{"type":"markdown","markdown":{"content":"Now, patterns of the form `<pattern> rebuild <name>` bind `name` to a function that takes all variables in `pattern` as parameters and rebuilds it from there. In the example above, `constructor` is equivalent to either `\\expr1 expr2 -> Add(expr1, expr2)` or `\\expr1 expr2 -> Sub(expr1, expr2)`, depending on the value of `expr`. "}},{"type":"markdown","markdown":{"content":"This also works for more complicated patterns where not every subpattern is a variable pattern, e.g."}},{"type":"markdown","markdown":{"content":"```\ndata Expr = ...\n          | If({ condition : Expr, thenBranch : Expr, elseBranch : Expr })"}},{"type":"markdown","markdown":{"content":"let replaceLeftmostLiteral(expr) = match expr {\n     Literal(n) -> Literal(0)\n     Add(expr, _) | Sub(expr, _) | If({ condition = expr | _ }) rebuild constructor ->\n        constructor(replaceLeftmostLiteral(expr))\n}\n``` "}},{"type":"markdown","markdown":{"content":"Is there some prior art on something similar to this?"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/848270-rebuild-patterns"}