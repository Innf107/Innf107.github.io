{"postId":801694,"headline":"Let generalization saves the day","publishedAt":"2023-01-07T16:33:48.633Z","shareOfPost":"https://cohost.org/fullmoon/post/801529-type-script-s-satisfi","state":1,"cws":[],"tags":["haskell","typescript","PLT"],"blocks":[{"type":"markdown","markdown":{"content":"This is possible with TemplateHaskell, by binding the expression to a (generalized) variable."}},{"type":"markdown","markdown":{"content":"If we define a `satisfies` splice as\n```hs\nsatisfies :: ExpQ -> TypeQ -> ExpQ\nsatisfies expr ty = [|let f = $expr in let _ :: $ty = f in f|]\n```\nthis will rewrite expressions of the form\n```hs\nid1 = $(satisfies [|\\x -> x|] [t|Int -> Int|])\n```\nto\n```hs\nid1 = let f = \\x -> x in \n      let _ :: Int -> Int = f in\n      f\n```\nwhich works just like `satisfies` in TypeScript."}},{"type":"markdown","markdown":{"content":"The reason this works is that the type of `f` is *generalized* to `forall a. a -> a` and so the types of `f` in `let _ :: Int -> Int = f` and the `f` that is returned are separate and, crucially, independent instantiations of `f`."}},{"type":"markdown","markdown":{"content":"This breaks down if `-XMonoLocalBinds` (implied by `-XGADTs` and `-XTypeFamilies`) is enabled and the expression mentions local variables from an outer scope, since GHC will refuse to generalize the binding in that case."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/801694-let-generalization-s"}