{"postId":2633596,"headline":"Apparently Polaris' constraint solver is non-confluent","publishedAt":"2023-08-26T22:51:42.751Z","state":1,"cws":[],"tags":["polaris","type systems","types","programming languages","programming","confluence","not that one though"],"blocks":[{"type":"markdown","markdown":{"content":"With a constraint based type checker, the order in which constraints are solved should generally not matter. This is called confluence and it is a pretty important property, since it ensures that the constraint solver can process constraints out of order and apply a whole bunch of other clever optimizations. It also makes the type system much more predictable for programmers."}},{"type":"markdown","markdown":{"content":"But... currently changing the order in which constraints in Polaris are solved can infer wildly different types and that is pretty bad."}},{"type":"markdown","markdown":{"content":"## The culprit: program argument constraints"}},{"type":"markdown","markdown":{"content":"One of the more fundamental features of Polaris are program calls. For example `!ls` is an expression that runs the program `ls` and returns it's output.\nOf course, programs can also take arguments, but what types should those arguments have? In the end, the operating system is only going to pass strings, but in polaris, lists of strings (and lists of lists of ... of lists of strings), numbers and even [functions](https://cohost.org/prophet/post/2484053-passing-closures-to) are all valid program arguments.\nThis is achieved by emitting a `ProgArg` constraint for the type of each argument, which is resolved correctly and quite elegantly for all of the above types."}},{"type":"markdown","markdown":{"content":"There is just one catch: What if the argument type is an unsolved unification variable?\nFor example, what should the type of the following function be?\n```\nlet f(x) = !ls x\n```\n`!ls` returns a string, but we know nothing about its argument other than that it has a `ProgArg` constraint. We cannot solve the constraint, so we should emit an ambiguity error and reject the program."}},{"type":"markdown","markdown":{"content":"But that's stupid! *Obviously*, the most natural type for this function is `String -> String` and that is almost surely what the programmer meant when they wrote it."}},{"type":"markdown","markdown":{"content":"So what polaris currently does is that, if the constraint solver fails to make progress, it *defaults* `ProgArg` constraints to `String`, correctly inferring `f : String -> String` for this example."}},{"type":"markdown","markdown":{"content":"## This defaulting breaks confluence"}},{"type":"markdown","markdown":{"content":"This is easier to explain if we assume Polaris had functional dependencies (which it might get at some point). Non-confluence should manifest without them as well, but even if it doesn't, that just delays the issue. "}},{"type":"markdown","markdown":{"content":"Let's say, we define a type class `C` with two functional dependencies on it's arguments\n```\nclass C(a, b) | a -> b, b -> a\ninstance C(String, Number)\ninstance C(List(String), String)\n```\nWhat this effectively means is that a constraint `C(String, x)` implies `x ~ Number` and `C(y, String)` implies `y ~ List(String)` (and vice versa)."}},{"type":"markdown","markdown":{"content":"Okay, now imagine we task our constraint solver with solving this sequence of constraints\n```\n1: ProgArg(?a)\n2: C(?a, ?b)\n3: ProgArg(?b)\n```\nNone of these can be solved directly, so our constraint solver will fail to make progress and start defaulting program arguments."}},{"type":"markdown","markdown":{"content":"If it starts with constraint (1), it will default `?a ~ String`. This unblocks the second constraint, now `C(String, ?b)`, which will be solved by our first instance and imply `?b ~ Number`.\nConstraint (3) is just `ProgArg(Number)` now, which is trivially solved, leaving us with the successful substitution\n```\n?a := String\n?b := Number\n```"}},{"type":"markdown","markdown":{"content":"This actually doesn't seem too unreasonable, but now consider what happens if our constraint solver decides to solve the constraints *in reverse*."}},{"type":"markdown","markdown":{"content":"If it starts at (3), it defaults `?b ~ String`, again unblocking (2), but with the second instance this time. This implies `?a ~ List(String)` now, which again leaves our third constraint to be trivially solved as it is just `ProgArg(List(String))` now.\nTherefore, our final substitution this time is\n```\n?a := List(String)\n?b := String\n```\nwhich *completely* contradicts the one from before, just because we changed the order in which constraints were solved (or emitted!)."}},{"type":"markdown","markdown":{"content":"## So what are we going to do?"}},{"type":"markdown","markdown":{"content":"One solution would be to default *all* `ProgArg` constraints at once. If we did this above, we would substitute both `?a := String` and `?b := String`, which would actually lead to the cosntraint solver rejecting the program above, because the functional dependency on `C` means that `C(String, String)` is impossible to solve."}},{"type":"markdown","markdown":{"content":"This does restore confluence, however it might lead to some *very* counter intuitive errors. Removing a type signature somewhere might make the constraint solver give up and default a type somewhere completely different that would have been resolved correctly before."}},{"type":"markdown","markdown":{"content":"I think there is a better way"}},{"type":"markdown","markdown":{"content":"## Generalizing program argument constraints\nProgram argument constraints predate type classes by a lot, but now that we finally have them, we might not actually need to default program arguments at all anymore!\nRemember that the entire reason we cared about defaulting was that we wanted to infer a type for declarations like `let f(x) = !ls x`."}},{"type":"markdown","markdown":{"content":"Now that we have type classes, we can just treat program argument constraints ~exactly like regular type class constraints and let users abstract over them! If we do this, we don't need to pick a concrete type for `x`. We can just generalize the function and infer a type `f : forall a. ProgArg(a) => a -> String`."}},{"type":"markdown","markdown":{"content":"Not only is this fully confluent, it also gives the programmer the power to do much more than they could before and possibly even leaves the door open for *custom* `ProgArg` instances in the future!"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/2633596-apparently-polaris"}