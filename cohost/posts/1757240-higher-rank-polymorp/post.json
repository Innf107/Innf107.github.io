{"postId":1757240,"headline":"Higher rank polymorphism despite monomorphization","publishedAt":"2023-06-25T23:45:03.841Z","state":1,"cws":[],"tags":["programming","programming languages","compilers","type systems","polymorphism"],"blocks":[{"type":"markdown","markdown":{"content":"The conventional wisdom in type systems is that monomorphization and higher rank polymorphism are fundamentally incompatible. I think I have found a nice solution that is able to unify the two!"}},{"type":"markdown","markdown":{"content":"## Let's start at the beginning"}},{"type":"markdown","markdown":{"content":"There are two main strategies for compiling polymorphic functions: type erasure and monomorphization."}},{"type":"markdown","markdown":{"content":"Type erasure is what languages like Haskell, OCaml and Java implement. With this strategy, every type internally has the same representation (usually a pointer to a heap allocation) and compilation just, well, *erases* types and compiles polymorphic functions exactly like monomorphic ones.\nWhile this has a few advantages, mostly that it is simple, compiles quickly and keeps executable sizes small, every value having the same representation makes it (mostly) impossible to have polymorphic functions that can act over unboxed values of different sizes, since calling conventions for these are different. Also, its performance is generally not fantastic, especially in languages with type classes that need to be compiled to indirect dictionaries, rather than directly inlining the type class methods."}},{"type":"markdown","markdown":{"content":"Monomorphization, which low level languages like Rust and C++ implement, takes a very different approach. Here, the compiler compiles *a separate instantiation* for every type that a polymorphic function is used at. Because every type gets its own instantiation, each one of these can be specialized and, ideally, optimized for that specific type and calling convention. Compiling type classes this way boils down to picking the right instance for the type that the current instantiation is being compiled at."}},{"type":"markdown","markdown":{"content":"The fundamental limitation of monomorphization now is that every instantiation of a polymorphic type has to be statically known, so that the compiler can pick the correct runtime implementation."}},{"type":"markdown","markdown":{"content":"## Higher rank polymorphism"}},{"type":"markdown","markdown":{"content":"Higher rank polymorphism allows functions to act over other *polymorphic* functions.\nFor example, this function (f) takes another function (g) as a parameter, that has to be valid for *any* type `a`. This means that `f` is able to use `g` at type `Int`, as well as `String`.\n```\nf : (forall a. a -> a) -> (Int, String)\nf(g) = (g(5), g(\"AAA\"))\n```"}},{"type":"markdown","markdown":{"content":"If you paid attention so far, you might see the issue already: There is no way for the compiler to statically know every instantiation of a higher rank polymorphic function. Even if it could, it would somehow have to pass `f` two copies of `g` and have `f` decide which one to use at runtime, which might not even be possible if `f` calls another higher rank polymorphic function."}},{"type":"markdown","markdown":{"content":"## The solution: restrict the types used in higher rank polymorphism"}},{"type":"markdown","markdown":{"content":"Higher rank polymorphism caused problems because it had to work for any type with any possible runtime representation."}},{"type":"markdown","markdown":{"content":"If we restrict it to any type with *the same representation*, we can compile it with type erasure, just like we would in Haskell or OCaml!"}},{"type":"markdown","markdown":{"content":"Note that this does not significantly reduce the type system's expressiveness, since any type can be wrapped in the same representation by boxing it (i.e. moving the value to the heap and keeping a pointer to it)."}},{"type":"markdown","markdown":{"content":"But how do we restrict types to \"the same runtime representation\"? We can take a page out of  GHC's playbook!"}},{"type":"markdown","markdown":{"content":"## [Kinds are calling conventions](https://www.pauldownen.com/publications/kacc.pdf)"}},{"type":"markdown","markdown":{"content":"In Haskell, types can have their own types, called **kinds**. E.g. `Int` has kind `Type`, whereas `Maybe` has kind `Type -> Type` and `MonadState` has kind `Type -> (Type -> Type) -> Constraint`."}},{"type":"markdown","markdown":{"content":"But GHC also supports unboxed types (although it doesn't support polymorphic functions ranging over every representation like our language, since it doesn't monomorphize them)."}},{"type":"markdown","markdown":{"content":"The way that GHC allows these while keeping polymorphism is by *encoding a type's representation in its kind*. `Type` from earlier is really just a kind synonym for `TYPE LiftedRep`, where `LiftedRep` represents any regular, lazy Haskell type that is represented by a pointer. By contrast, `Int#`, the type of unboxed integers has kind `TYPE IntRep` and `Double#` has kind `TYPE DoubleRep`."}},{"type":"markdown","markdown":{"content":"This is what we need!\nIn our hypothetical language then, a rank 1 polymorphic function definition with a top-level forall like this\n```\nf : forall a. a -> a\nf(x) = x\n```\nis really just syntactic sugar for a representation polymorphic function (that will be monomorphized accordingly)\n```\nf : forall (r : RuntimeRep) (a : TYPE r). a -> a\nf(x) = x\n```"}},{"type":"markdown","markdown":{"content":"Higher rank polymorphic functions are only valid with monomorphic runtime representations. I.e. the following is fine and equivalent to what we had earlier without monomorphization\n```\nf : (forall (a : TYPE LiftedRep). a -> a) -> (Int, String)\nf(g) = (g(5), g(\"AAA\"))\n```\nBut the following will be rejected because it is polymorphic over the representation of `a`.\n```\nf : (forall (r : RuntimeRep) (a : TYPE r). a -> a) -> (Int64, String)\nf(g) = (g(5 : Int64), g(\"AAA\"))\n```"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/1757240-higher-rank-polymorp"}