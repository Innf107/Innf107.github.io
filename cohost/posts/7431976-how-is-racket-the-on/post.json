{"postId":7431976,"headline":"How is Racket the only serious \"multi-paradigm\" programming language","publishedAt":"2024-08-25T23:46:46.484Z","state":1,"cws":[],"tags":["programming languages","PLT","haskell","ocaml","racket","functional programming"],"blocks":[{"type":"markdown","markdown":{"content":"\"Programming paradigms\" are a pretty vague and frankly not very meaningful concept but if you're going to argue that your programming language supports both imperative and functional programming, you'll at the very least have to give me access to mutable *and* persistent data structures."}},{"type":"markdown","markdown":{"content":"Racket does this quite nicely by giving you two mostly compatible versions of each (e.g. `hash` creates an immutable hash table and `make-hash` creates a mutable one but you can access both with `hash-ref`) but that's kind of... it?"}},{"type":"markdown","markdown":{"content":"Some Haskell packages work like this (notably vector) but overall the support for good mutable data structures there is pretty lacking."}},{"type":"markdown","markdown":{"content":"OCaml likes to pretend that it's good at this but it actually only has some fundamental data structures that are immutable (e.g. lists, sets) and some that are mutable (e.g. arrays, queues).\nThis means that e.g. because there are no immutable arrays, there is also no fast slicing operation on arrays and so you'll pretty much be forced to use a more imperative style with them because you can't even write a generic function on arrays without passing around indices like a Neanderthal."}},{"type":"markdown","markdown":{"content":"And functional JS makes you do linear time slicing/concatenation on mutable arrays in a loop :)"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/7431976-how-is-racket-the-on"}