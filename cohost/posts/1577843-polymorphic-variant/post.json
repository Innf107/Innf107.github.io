{"postId":1577843,"headline":"Polymorphic variant inference that beats OCaml","publishedAt":"2023-05-29T10:28:29.101Z","state":1,"cws":[],"tags":["polaris","ocaml","type systems","programming languages"],"blocks":[{"type":"markdown","markdown":{"content":"You may remember that a few months ago, I spent [quite some time implementing type inference for polymorphic variant patterns](https://cohost.org/prophet/post/802188-i-did-not-expect-to) in Polaris. In that post, I settled on roughly the same approach as OCaml. As it turns out, we can do much better!"}},{"type":"markdown","markdown":{"content":"## A quick recap\nThe issue with inference for these kinds of patterns is that sometimes, polymorphic variant patterns should be inferred to a closed variant type and sometimes to an open type\n```\n# This should have type f : < A, B > -> Bool\nlet f(x) = match x {\n    A -> true\n    B -> false\n}"}},{"type":"markdown","markdown":{"content":"# This should have type g : forall r. < A, B | r > -> Bool\nlet g(x) = match x {\n    A -> true\n    B -> false\n    _ -> false\n}\n```"}},{"type":"markdown","markdown":{"content":"The solution taken by both Polaris and OCaml is to always infer an open variant type and then later check the patterns for exhaustiveness and close the type when appropriate (by setting the row variable to the empty variant `<>`)."}},{"type":"markdown","markdown":{"content":"## This is not enough"}},{"type":"markdown","markdown":{"content":"Consider this function (This may seem a bit artificial, but I ran into something similar in a real Polaris script!)"}},{"type":"markdown","markdown":{"content":"```\nlet f(x) = match x {\n    A -> B\n    y -> y\n}\n```\nWhat is the type of `y`? Both OCaml and current Polaris will infer `< A, B | ?r >`, and therefore infer the full type `f : forall r. < A, B | r > -> < A, B | r >`.\nBut if you look closely, you will notice that this is not actually correct! `y` can *never* be `A`, because in that case, the pattern above it will match."}},{"type":"markdown","markdown":{"content":"It gets a bit more complicated still. If we change the function slightly,\n```\nlet f(x) = match x {\n    (A, 5) -> B\n    (y, _) -> y\n}\n```"}},{"type":"markdown","markdown":{"content":"the first pattern may not match, even if the first component is `A`, so `y` *can* be `A` now!"}},{"type":"markdown","markdown":{"content":"Fortunately, there is a relatively simple rule to figure out when to refine variants. We know that all further patterns cannot contain a variant, whenever a pattern is **otherwise irrefutable** (i.e. will always match).\nFor example, `((A, x), _)` is irrefutable apart from the variant pattern `A`, but `(A, 5)` is not, because `5` is not irrefutable."}},{"type":"markdown","markdown":{"content":"We can then infer the correct type for the function above (`forall r. < A, B | r > -> < B | r >`), by *refining* the variant for the remaining patterns."}},{"type":"markdown","markdown":{"content":"## But how do you implement refinement?"}},{"type":"markdown","markdown":{"content":"This is a little harder for Polaris than it would be for OCaml, since Polaris' type system is constraint based. This means we usually cannot match on types directly during type inference as they may still contain unification variables that will later be substituted by the constraint solver."}},{"type":"markdown","markdown":{"content":"Right now, match expressions are inferred like this:"}},{"type":"markdown","markdown":{"content":"- Type inference infers the type of the scrutinee (`x` in the example above. In the difficult case, this is just a unification variable)\n- All patterns are independently checked against this type\n- The body of each case is inferred and the types are all unified. The resulting type is the type of the result of the match expression"}},{"type":"markdown","markdown":{"content":"To refine variant types, we need to take a slightly different approach:"}},{"type":"markdown","markdown":{"content":"- We still infer the type of the scrutinee and use this as the working type\n- Patterns are checked *in order* from top to bottom. \n- After checking one pattern, we see if the pattern is irrefutable apart from a single variant pattern. If it is, we remember that variant constructor, as well as a *path* to it in the full type.\n- Accordingly, we emit a constraint `RefineVariant (original_type, path, variant, refined_type)`, where `original_type` is the type we matched the pattern against and `refined_type` is a fresh unification variable.\n- When encountering one of these constraints, the constraint solver will traverse the path in the type (which is now fully constructed), remove the desired variant and bind the resulting type to `refined_type`. \n- We continue by recursing on the other patterns, except that this time, we check them against `refined_type`. \n- Inference for the case bodies remains unchanged."}},{"type":"markdown","markdown":{"content":"And that's it! For only a bit more effort, this should infer polymorphic variants much more precisely than OCaml!"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/1577843-polymorphic-variant"}