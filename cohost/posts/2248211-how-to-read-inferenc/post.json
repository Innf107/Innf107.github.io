{"postId":2248211,"headline":"How to read inference rules","publishedAt":"2023-07-28T19:55:38.529Z","state":1,"cws":[],"tags":["type inference","programming languages","type systems"],"blocks":[{"type":"markdown","markdown":{"content":"\nThe notation used is probably one of the largest barriers of entry to type inference papers, but it is rarely explained explicitly, so... I'm going to do just that!"}},{"type":"markdown","markdown":{"content":"For starters, inference rules are really nothing more than implications. The inference rule"}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mi>A</mi><mi>B</mi></mfrac><mo stretchy=\"false\">(</mo><mtext>Name</mtext><mo stretchy=\"false\">)</mo></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"really just means \"if A then B\". These are usually given a name (in this case, creatively, <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mtext>Name</mtext></mrow></semantics></math></span>) to make it easier to refer to them in the rest of the paper."}},{"type":"markdown","markdown":{"content":"Now, even though these are technically just implications, it's usually not a great idea to read them from top to bottom. Inference rules denote relations, but it usually usually makes more sense to read them as (possibly non-deterministic) functions.\nFor example, a judgement for typing function application might look like this. (where <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>e</mi><mo>:</mo><mi>τ</mi></mrow></semantics></math></span> means \"In a context <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>, the type of an expression <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>e</mi></mrow></semantics></math></span> is infered to <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi></mrow></semantics></math></span>\")"}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub>      <mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo>  <mo>:</mo>  <msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mo stretchy=\"false\">(</mo><mtext>App</mtext><mo stretchy=\"false\">)</mo></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"Naively, one might read this as\n<blockquote>\nIf <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow></semantics></math></span> has type <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></semantics></math></span> in a context <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span> and <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></semantics></math></span> has type <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></semantics></math></span> in <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>, then <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></semantics></math></span> has type <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></semantics></math></span> in <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>\n</blockquote>"}},{"type":"markdown","markdown":{"content":"but a much better way to read it, that is much closer to an actual implementation, would be\n<blockquote>\nIn order to infer a type for <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></semantics></math></span> in a context <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>, one first needs to infer a type for <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub></mrow></semantics></math></span> with shape <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub><mo>→</mo><msub><mi>τ</mi><mn>2</mn></msub></mrow></semantics></math></span> in <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>. Now <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></semantics></math></span> also needs to infer to type <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></semantics></math></span> in <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>, so that the result (i.e. the type of <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><msub><mi>e</mi><mn>2</mn></msub><mo stretchy=\"false\">)</mo></mrow></semantics></math></span>) is <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>2</mn></msub></mrow></semantics></math></span>.\n</blockquote>"}},{"type":"markdown","markdown":{"content":"Read this way, the inference rule maps very closely onto an actual implementation! Seriously, compare the corresponding pseudocode to that second description"}},{"type":"markdown","markdown":{"content":"<pre>infer Γ (App e1 e2) =\n    let (τ1 -&gt; τ2) = infer Γ e1\n    let τ3 = infer Γ e2\n    unify τ1 τ3\n    return τ2\n</pre>"}},{"type":"markdown","markdown":{"content":"The only major difference between this code (which skips error handling, just like inference rules) and the inference rule is that the fact that the type of <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></semantics></math></span> needs to be equal to <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>τ</mi><mn>1</mn></msub></mrow></semantics></math></span> is explicit in the code (`unify τ1 τ3`)."}},{"type":"markdown","markdown":{"content":"Reading off the algorithm like this is possible if the inference rules are syntax directed, i.e. if there is only ever a single rule that might match on a given expression. This is not always the case, so sometimes it's better to imagine non-deterministically choosing the correct rule to apply, rather than just pattern matching."}},{"type":"markdown","markdown":{"content":"And that's... pretty much all you need to know to read inference rules!"}},{"type":"markdown","markdown":{"content":"There are a few common conventions in type systems that might be a bit surprising, so let's go over those as well"}},{"type":"markdown","markdown":{"content":"## Environments and extension"}},{"type":"markdown","markdown":{"content":"Type inference needs an environment to keep track of the types of variables. This is usually called <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span> and extended as <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi>  <mo>:</mo>  <mi>τ</mi></mrow></semantics></math></span>."}},{"type":"markdown","markdown":{"content":"For example, this inference rule for (annotated) let bindings checks <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>2</mn></msub></mrow></semantics></math></span> under the environment Γ, extended with the binding <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>x</mi>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub></mrow></semantics></math></span>."}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub>      <mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mrow><mtext mathvariant=\"bold\">let</mtext><mtext>&nbsp;</mtext></mrow><mi>x</mi>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mrow><mtext>&nbsp;</mtext><mtext mathvariant=\"bold\">in</mtext><mtext>&nbsp;</mtext></mrow><msub><mi>e</mi><mn>2</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac><mtext>Let</mtext></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"Extracting information from the environment is achieved through \"pattern matching\" on the environment, for example in this inference rule for variables."}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi>  <mo>:</mo>  <mi>τ</mi><mo>⊢</mo><mi>x</mi>  <mo>:</mo>  <mi>τ</mi></mrow></mfrac><mtext>Var</mtext></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"## Unification variables\n[Unification variables](https://cohost.org/prophet/post/2220730-if-there-is-one-piec) don't exist in theoretical type systems, but they still map very directly onto a similar concept. Instead of generating a fresh unification variable, inference rules just \"guess\" a new type (they're relations, remember?)."}},{"type":"markdown","markdown":{"content":"For example, this typing rule for (unannotated) lambdas just pulls the type <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>τ</mi></mrow></semantics></math></span> out of thin air."}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi>  <mo>:</mo>  <mi>τ</mi><mo>⊢</mo><mi>e</mi>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mi>λ</mi><mi>x</mi><mo>→</mo><mi>e</mi>  <mo>:</mo>  <mi>τ</mi><mo>→</mo><msub><mi>τ</mi><mn>1</mn></msub></mrow></mfrac><mtext>Lambda</mtext></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"## Lists\nSomething you will see pretty often in papers by Simon Peyton Jones are lists that are represented by an overline. E.g. the syntax for uncurried function application might be <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><msub><mi>e</mi><mn>1</mn></msub><mo stretchy=\"false\">(</mo><mover accent=\"true\"><mi>e</mi><mo stretchy=\"true\">‾</mo></mover><mo stretchy=\"false\">)</mo></mrow></semantics></math></span>, where <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mover accent=\"true\"><mi>e</mi><mo stretchy=\"true\">‾</mo></mover></mrow></semantics></math></span> consists of 0 or more expressions."}},{"type":"markdown","markdown":{"content":"## Skolems\nSimilarly, skolems don't exist as a separate concept. Instead, \"unbound\" type variables are treated as skolems, although these obviously cannot conflict with any other type variables in scope!\nIn an implementation, this would be achieved by generating a fresh skolem, but in inference rules, this is expressed by the side condition that the type variable should not occur \"free in the environment\", written <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi>a</mi><mo mathvariant=\"normal\">∉</mo><mtext>ftv</mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo></mrow></semantics></math></span>, where ftv denotes the set of free type variables (= skolems) in <span><math xmlns=\"http://www.w3.org/1998/Math/MathML\"><semantics><mrow><mi mathvariant=\"normal\">Γ</mi></mrow></semantics></math></span>."}},{"type":"markdown","markdown":{"content":"For example, a rule for let bindings with polymorphic types (that need to be skolemized) might look like this"}},{"type":"markdown","markdown":{"content":"<span><math xmlns=\"http://www.w3.org/1998/Math/MathML\" display=\"block\"><semantics><mrow><mfrac><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><msub><mi>e</mi><mn>1</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>1</mn></msub>      <mover accent=\"true\"><mi>a</mi><mo stretchy=\"true\">‾</mo></mover><mo mathvariant=\"normal\">∉</mo><mtext>ftv</mtext><mo stretchy=\"false\">(</mo><mi mathvariant=\"normal\">Γ</mi><mo stretchy=\"false\">)</mo>      <mi mathvariant=\"normal\">Γ</mi><mo separator=\"true\">,</mo><mi>x</mi>  <mo>:</mo>  <mi mathvariant=\"normal\">∀</mi><mover accent=\"true\"><mi>a</mi><mo stretchy=\"true\">‾</mo></mover><mi mathvariant=\"normal\">.</mi><msub><mi>τ</mi><mn>1</mn></msub><mo>⊢</mo><msub><mi>e</mi><mn>2</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>2</mn></msub></mrow><mrow><mi mathvariant=\"normal\">Γ</mi><mo>⊢</mo><mrow><mtext mathvariant=\"bold\">let</mtext><mtext>&nbsp;</mtext></mrow><mi>x</mi>  <mo>:</mo>  <mi mathvariant=\"normal\">∀</mi><mover accent=\"true\"><mi>a</mi><mo stretchy=\"true\">‾</mo></mover><mi mathvariant=\"normal\">.</mi><msub><mi>τ</mi><mn>1</mn></msub><mo>=</mo><msub><mi>e</mi><mn>1</mn></msub><mrow><mtext>&nbsp;</mtext><mtext mathvariant=\"bold\">in</mtext><mtext>&nbsp;</mtext></mrow><msub><mi>e</mi><mn>2</mn></msub>  <mo>:</mo>  <msub><mi>τ</mi><mn>2</mn></msub></mrow></mfrac></mrow></semantics></math></span>"}},{"type":"markdown","markdown":{"content":"## Where to go from here"}},{"type":"markdown","markdown":{"content":"  Great, with a little practice, you should be able to read inference rules now! I would recommend you read [Practical type inference for higher rank types](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/putting.pdf), which is a great, relatively beginner friendly paper about type inference that even contains a full implementation at the end! (And despite the name, is not just about higher rank types).\n"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/2248211-how-to-read-inferenc"}