{"postId":3031893,"headline":"How to implement effect handlers","publishedAt":"2023-10-01T23:18:44.717Z","state":1,"cws":[],"tags":["polaris","Vega","programming","programming languages","functional programming","algebraic effects","(how did that tag not exist before?)","Effects","PLT","programming language development","pldev","systems programming"],"blocks":[{"type":"ask","ask":{"askId":"938352292187342847","anon":false,"loggedIn":true,"askingProject":{"projectId":32173,"avatarPreviewURL":"https://staging.cohostcdn.org/avatar/32173-8b30036a-55a1-4584-8937-04716e22532d-profile.png","avatarShape":"roundrect","avatarURL":"https://staging.cohostcdn.org/avatar/32173-8b30036a-55a1-4584-8937-04716e22532d-profile.png","flags":[],"handle":"Quelklef","privacy":"public","displayName":"Maynard"},"content":"polaris has algebraic effects, right? how did you implement them?\n\ni know they can be done with free monads but i have a hunch that that's not the route you opted to take","sentAt":"2023-10-01T16:18:30.100Z"}},{"type":"markdown","markdown":{"content":"It doesn't, actually ^^\nI've thought about implementing them, but fine grained effects just aren't very useful for the kinds of scripts you might want to write in Polaris and the extra type level complexity gets in the way too much."}},{"type":"markdown","markdown":{"content":"Buut, Vega will have algebraic effects! I've also implemented them for a different language before so I have a pretty good idea of how they're going to work."}},{"type":"markdown","markdown":{"content":"So, implementing effects on top of free monads is technically possible, but it's honestly a pretty terrible idea. I'm not a massive fan of free monads in general, but building up and later traversing a heap allocated tree for *every* effectful expression is pretty ridiculous."}},{"type":"markdown","markdown":{"content":"The standard implementation approaches are much more similar to, or even based on delimited continuations[^koka].\nThe key insight here is that a continuation is really not much more than a call stack and a *delimited* continuation (up until an effect handler) is just a delimited part of the call stack.\nTherefore, capturing a continuation just involves copying parts of the stack and continuing just copies them back. \nAlexis King has an [amazing talk](https://www.youtube.com/watch?v=DRFsodbxHQo) about this."}},{"type":"markdown","markdown":{"content":"What I'm going to do is based on what [OCaml 5](https://arxiv.org/pdf/2104.00250.pdf) does though.\nThe idea behind this approach is that if a continuation is used *linearly* (like the coroutine-like effects that are relevant to Multicore OCaml), the delimited call stack never actually needs to be duplicated.\nSo what one can do is represent the program stack as a hybrid growable/segmented stack where every handler creates a new stack segment that is linked back to the previous through a pointer.\nNow performing an effect walks the stack to find the closest handler (just like throwing an exception would) and continues execution on *its* stack segment. Because there is a segment boundary between them, nothing in the suspended continuation will be overriden. When the continuation is resumed, control jumps back forward to the segment where the effect was performed, which is linked back to the point where the handler stack has resumed it."}},{"type":"markdown","markdown":{"content":"The diagrams in [the paper](https://arxiv.org/pdf/2104.00250.pdf) are prettier than this, but you'll have to bear with my ASCII art for this example."}},{"type":"markdown","markdown":{"content":"Let's say your program looks something like this, where the expression at the `<--` is currently being evaluated\n```\nf () = {\n    let x = 5\n    let returned = handle {\n        let y = 6\n        let result = perform SomeEffect <---\n        result + 1\n    } with {\n        SomeEffect cont ->\n            \\x -> continue cont x\n        }\n    }\n    let z = 7\n    let w = 8\n    returned 9\n}\n```\nThis is a pretty contrived example but all it does is perform an effect that is handled by returning the continuation as a function, which is then called with 9 as an argument."}},{"type":"markdown","markdown":{"content":"Initially, the call stack for this is going to look something like this (where stacks grow downwards)\n```\n+-------+\n| x = 5 |   # the containing function\n+-------+\n    ^\n    |\n+-------+\n| y = 6 |  # the part inside the handle expression\n+-------+ <-- stack ptr\n```"}},{"type":"markdown","markdown":{"content":"Performing the effect will disconnect the second segment and continue execution on the initial one while jumping to the correct handler code. `cont` is now given a pointer to the disconnected stack segment (= delimited continuation)"}},{"type":"markdown","markdown":{"content":"```\n+---------+\n| x = 5   |\n| cont = ------------------+\n+---------+ <-- stack ptr  |\n                           |\n+---------+                |\n| y = 6   | <--------------+\n+---------+\n```"}},{"type":"markdown","markdown":{"content":"The handler further mutates and expands the first stack segment (which is fine since the second one is completely independent of it now!). It even returns the continuation wrapped in a function so at the point just before `returned 9`, the stack will look like this"}},{"type":"markdown","markdown":{"content":"```\n+------------+\n| x = 5      |\n| returned = ---------------> closure\n| z = 7      |                   |\n| w = 8      |                   |\n+------------+ <-- stack ptr     |\n                                 |\n+---------+                      |\n| y = 6   | <--------------------+\n+---------+\n```"}},{"type":"markdown","markdown":{"content":"Now all that continuing the continuation needs to do is link the second stack segment back to the first one and jump to the correct location in the code. It also invalidates the continuation inside `returned` since the stack segment will now be mutated and so cannot be resumed again."}},{"type":"markdown","markdown":{"content":"```\n+------------+\n| x = 5      |\n| returned = ---------------> closure\n| z = 7      |                   |\n| w = 8      |                   |\n+------------+                   X\n    ^                            \n    |                            X\n+---------+                      |\n| y = 6   | <--------------------+\n+---------+ <-- stack ptr\n```"}},{"type":"markdown","markdown":{"content":"And that's it! Notice how none of this ever had to copy stack frames around or do any operations that were not constant in the size of the call stack (other than finding the handler which can be done very efficiently)."}},{"type":"markdown","markdown":{"content":"Importantly though this approach only works for one-shot continuations that are only used once. Trying to use the continuation more than once doesn't work because the call stack has already been used up the first time[^leak]."}},{"type":"markdown","markdown":{"content":"In Vega, I'm going to need to have both linear and non-linear effects anyway since linear resources cannot be carried across calls to non-linear effects, so I can use that to take this fast path in the linear case and copy the continuation segment in the non-linear case so that it can be reused."}},{"type":"markdown","markdown":{"content":"Oh and if you're writing a dumb tree-walk interpreter, CPS is enough to capture the continuation. That's how I implemented effects in Flora."}},{"type":"markdown","markdown":{"content":"[^koka]: For example, [Koka desugars its effects to C/Java/JS through a multi-prompt continuation monad and a way of implicitly passing around prompt tags](https://www.microsoft.com/en-us/research/uploads/prod/2021/08/genev-icfp21.pdf).\n[^leak]: If the continuation is never used, it will stick around and leak memory. This can be mitigated by registering a finalizer in the GC and letting it clean up unused continuations, but that has a sizeable performance cost so it's not what OCaml does for its rather low level effects and I have linearity to ensure that they're used or explicitly discontinued in Vega."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/3031893-how-to-implement-eff"}