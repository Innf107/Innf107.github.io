{"postId":2950282,"headline":"It's wild how easily imperative languages leak implementation details","publishedAt":"2023-09-24T13:54:30.720Z","state":1,"cws":[],"tags":["programming","functional programming","programming languages","ocaml","purity","haskell"],"blocks":[{"type":"markdown","markdown":{"content":"Functional programmers always go on about how purity makes programs \"easier to reason about\", but honestly, it's much more important that purity seems to be the only way to keep programs from leaking their internal implementation details *everywhere*."}},{"type":"markdown","markdown":{"content":"Imagine you're writing an implementation of `List.map2` in OCaml (`zipWith` in Haskell). In OCaml, this throws an exception or returns `None` if the lists have different lengths, so you might write it like this."}},{"type":"markdown","markdown":{"content":"```\nlet map2 f list1 list2 =\n    if List.compare_length list1 list2 <> 0 then\n        None\n    else\n        let go list1 list2 = match list1, list2 with\n            | ([], _) | (_, []) -> []\n            | (x :: xs, y :: ys) -> f x y :: go xs ys\n        in\n        Some (go list1 list2)\n```\nThis works, so you publish it, get a bunch of people to use it and forget about it for a few months."}},{"type":"markdown","markdown":{"content":"One day you look back at your code and notice that this is kind of inefficient since it needs to traverse the lists twice, once to check the length and once to actually do the mapping.\nYou realize that it's possible to merge the two traversals and only bail out at the end, so you rewrite your code"}},{"type":"markdown","markdown":{"content":"```\nlet map2 f list1 list2 =\n    match list1, list2 with\n    | ([], []) -> Some []\n    | ([], _) | (_, []) -> None\n    | (x :: xs, y :: ys) -> Option.map (fun rest -> f x y :: rest) (map2 f xs ys)\n```"}},{"type":"markdown","markdown":{"content":"And congrats: You just broke your public interface!"}},{"type":"markdown","markdown":{"content":"If `f` performs a side effect, the first implementation would never perform that effect on lists with different lengths, whereas the second one will until it hits the end of the shorter one."}},{"type":"markdown","markdown":{"content":"Good luck finding that bug."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/2950282-it-s-wild-how-easily"}