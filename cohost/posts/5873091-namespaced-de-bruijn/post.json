{"postId":5873091,"headline":"Namespaced De Bruijn indices for duplicate record fields","publishedAt":"2024-05-07T16:42:02.709Z","state":1,"cws":[],"tags":["programming languages","PLT","functional programming","programming language theory","type systems","row polymorphism"],"blocks":[{"type":"markdown","markdown":{"content":"[Namespaced De Bruijn indices](https://www.haskellforall.com/2021/08/namespaced-de-bruijn-indices.html) are a really neat trick for representing names in programming language interpreters that I learned from @fullmoon.\nIn short, the idea is pretty much that you can access shadowed variables by starting at their last occurence and counting up.\nSo for example, in this code\n```\nlet x = 1\nlet y = 2\nlet x = 3\nlet y = 4\nlet x = 5\n```\n`x` (which is equivalent to `x@0`) is assigned 5, `x@1` is 3, `x@2` is 1, `y` and `y@0` are 4 and `y@1` is 2."}},{"type":"markdown","markdown":{"content":"The way Gabby uses this is mostly intended for interpreters that need to do capture avoiding substitution. But even in a compiler, these are actually quite useful in combination with a feature that might seem completely unrelated at first!"}},{"type":"markdown","markdown":{"content":"## Row polymorphism with duplicate labels\nAt this point, row polymorphism isn't actually that uncommon. It's a way to represent anonymous record types and abstract over the fields of a record without needing subtyping (which would make type inference difficult and might lose information).\nFor example, a function that takes any record that has an `x` field of type `Int` and a `y` field of type `String` and that replaces the value of `y` with something of type `Bool` can look like this. (where `r` is the row that represents the remaining fields)\n```\nlet f : forall r. { x : Int, y : String | r } -> { x : Int, y : Bool | r }\nlet f(r) = { r with y = r.x > 0 }\n```"}},{"type":"markdown","markdown":{"content":"Now, one problem that quickly comes up with row polymorphism is how to do record extensions.\nIt would be quite convenient to be able to write a function that adds a field to a record like this\n```\nlet f : forall r. { | r } -> { x : Int | r }\nlet f(r) = { r extend x =  5 }\n```\nThis seems innocent enough, but consider what happens if you call this function on `{ x = \"a\" }`. \nThe record already has an `x` field so you can't exactly add another, can you? You could give up here and make the programmer ensure that `f` is never called on a record that already has an `x` field, and some row polymorphism implementations really do this in practice! (for example with qualified types / type class constraints)."}},{"type":"markdown","markdown":{"content":"But a much more elegant answer is given in the paper [Extensible records with scoped labels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/scopedlabels.pdf) that e.g. Elm and Purescript[^purescript] are based on.\nIts answer to row extensions is: just allow duplicate fields! If you apply `f` to `{ x = \"a\" }`, you just get `{ x = 5, x = \"a\" }`, which has type `{ x : Int, x : String }`.\nThis means that the order of fields is not entirely irrelevant anymore, but fortunately the type system only needs to preserve the order of fields *with the same name* so it's barely noticable in practice."}},{"type":"markdown","markdown":{"content":"If you paid attention, you might now be asking \"how do I access the second `x` field?\". And the traditional answer to this is: you don't! The row extension has shadowed the inner `x`, so the only way to access it now is to remove the outer field. If your type system even supports that (most don't).\nBuuut..."}},{"type":"markdown","markdown":{"content":"## We can use namespaced De Bruijn indices!\nIf you want to access the second `x` field of a record, you can just write `r.x@1`! And if you want to access the, say, 27th field, you just write `r.x@26`!\nThis also works seamlessly with polymorphism and type inference. For example, a generic function like `f(r) = r.x@2` would easily be inferred to have type `f : forall r a b c. { x : a, x : b, x : c | r } -> c`."}},{"type":"markdown","markdown":{"content":"I think this is pretty cute :)\n[^purescript]: ~~As far as I know. Don't quote me on this ^^~~ Well, [kind of](https://cohost.org/monoidmusician/post/5886144-nice-the-main-rea)"}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/5873091-namespaced-de-bruijn"}