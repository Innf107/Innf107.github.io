{"postId":4438218,"headline":"Function coloring is good actually","publishedAt":"2024-02-10T23:28:55.829Z","state":1,"cws":[],"tags":["programming","programming languages","async","async/await"],"blocks":[{"type":"markdown","markdown":{"content":"So, one thought I've been having a lot recently regarding \"function coloring\" is that I really do not believe that async functions being colored at all is the issue. I actually think it's good!"}},{"type":"markdown","markdown":{"content":"Really, what I think is a lot more relevant is that languages with async/await typically have *two* ways of doing IO: one that is sync and untagged and one that is async and tagged.\nThis means that even functions that are intended to do IO are usually written as sync functions by default and so of course doing something asynchronous somewhere contaminates most of the codebase with \"unnecessary\" async functions."}},{"type":"markdown","markdown":{"content":"If all IO in a language were async, I really don't think people would complain about coloring nearly as much as they do, since it would be pretty obvious ahead of time if a function needs to be async or not.\nIf you're calling a function that doesn't seem like it should read from or write to files but in reality it calls a function that does, *that's an issue*! You would *want* your compiler to prevent you from doing that, wouldn't you?"}},{"type":"markdown","markdown":{"content":"In fact, Haskell's IO monad kind of works like that and it's great! This isn't quite a fair comparison since Haskell's notion of IO is a lot broader than the one used by async, but I still think it shows that the coloring itself is not the issue."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/4438218-function-coloring-is"}