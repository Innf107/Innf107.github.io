{"postId":439858,"headline":"TemplateHaskell crimes","publishedAt":"2022-11-24T16:09:41.091Z","state":1,"cws":[],"tags":["haskell","TemplateHaskell","crimes"],"blocks":[{"type":"markdown","markdown":{"content":"Sometimes when working with TemplateHaskell, you would like to attach some additional meta information to data constructors. For example, I came up with this when working on a compiler, where I had a function to pretty print expressions with a case for every single expression."}},{"type":"markdown","markdown":{"content":"Writing out a new case for every single constructor in a different part of the file was getting quite annoying, so I wanted to use TemplateHaskell to make this a bit simpler. If this had been in Rust, I could have written the pretty printing information in doc comments like this:"}},{"type":"markdown","markdown":{"content":"```hs\ndata Expr \n    -- | pretty: $0\n    = Var Name\n    -- | pretty: λ$0. $1\n    | Lambda Name Expr\n    -- | pretty: ($0) ($1)\n    | App Expr Expr\n```\nUnfortunately, this doesn't work in Haskell, since TemplateHaskell doesn't have access to Haddock comments."}},{"type":"markdown","markdown":{"content":"There is another way though!"}},{"type":"markdown","markdown":{"content":"Did you know that GADT constructors don't actually need to return the type they are defining?"}},{"type":"markdown","markdown":{"content":"For example: in this code, `Florb` doesn't actually need to return something of type `Flurb`!"}},{"type":"markdown","markdown":{"content":"```hs\ndata Flurb where\n     Florb :: Int -> Flurb\n```\nIt only needs to return something that *unifies* with `Flurb`."}},{"type":"markdown","markdown":{"content":"This compiles!\n```hs\ntype DefinitelyNotFlurb = Flurb"}},{"type":"markdown","markdown":{"content":"data Flurb where\n     Florb :: Int -> DefinitelyNotFlurb\n```"}},{"type":"markdown","markdown":{"content":"We don't need to constrain ourselves to simple type aliases like this. We can even add a type parameter to our synonym, and TemplateHaskell will see the exact type we wrote down, ignored type parameters and everything!"}},{"type":"markdown","markdown":{"content":"With this, we can finally add prettyprinting annotations to our `Expr` type."}},{"type":"markdown","markdown":{"content":"```hs\ntype PrettyAnn :: Symbol -> Type -> Type\ntype PrettyAnn s a = a"}},{"type":"markdown","markdown":{"content":"data Expr where\n    Var    :: Name -> PrettyAnn \"$0\" Expr\n    Lambda :: Name -> Expr -> PrettyAnn \" λ$0. $1\" Expr\n    App    :: Expr -> Expr -> PrettyAnn \"($0) ($1)\" Expr\n    deriving (Eq)\n```\nEven better: GHC can see that these aren't real GADTs, so deriving clauses still just work."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/439858-template-haskell-crim"}