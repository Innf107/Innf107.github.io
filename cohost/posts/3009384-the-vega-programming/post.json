{"postId":3009384,"headline":"The Vega Programming Language","publishedAt":"2023-09-29T17:59:05.089Z","state":1,"cws":[],"tags":["programming","programming languages","haskell","pldev","programming language development","type systems","aahh why are there so many tags for the same concept?","Vega"],"blocks":[{"type":"markdown","markdown":{"content":"Since announcing projects before having anything to show for them is apparently en vogue now, I guess I'll join in and announce that I'm building another programming language! \nYeah yeah I know, working on two languages at the same time is a ton of effort, but this is *my* project so *I*'m the one who gets to decide what's a bad idea :)"}},{"type":"markdown","markdown":{"content":"Unlike Polaris, which is relatively specialized to shell-like freestanding scripts, the goal for Vega is to be the ideal general purpose programming language I would want to use. As such, it's going to be somewhat similar to Haskell, my favorite existing language, but with some significant differences.\nSome of the notable features I'm going for are\n- (hopefully lightweight) dependent types\n- good type inference\n- direct-style row-polymorphic algebraic effects\n- globally coherent type classes (like Haskell's and Polaris' but unlike Coq's)\n- linearity\n- good C FFI\n- first class implicit existential types\n- anonymous row-polymorphic records and maybe polymorphic variants"}},{"type":"markdown","markdown":{"content":"A cool consequence of dependent types is that they give you ML-style modules pretty much for free since a module can just be represented as a record of values and types (like modules in Dhall or Lua) and a functor is just a function that transforms modules."}},{"type":"markdown","markdown":{"content":"As for the runtime system, I'll probably do something similar to OCaml 5 with segmented stacks for extremely efficient one-shot effects. Thanks to linearity, a handler could then specify whether it uses its continuation linearly or not and only take the slow route (that involves copying stack frames) in the non-linear case.\nLinearity also helps model resource acquisition without the need for stack unwinding or anything like that (since linear resources cannot be passed across calls to functions with non-linear effects)"}},{"type":"markdown","markdown":{"content":"But for now, I've only got a half-written dependent type checker with decent inference working."}},{"type":"markdown","markdown":{"content":"It's written in Haskell this time, which is quite nice after mostly working in OCaml for Polaris. OCaml is fun and all, but wow, there are a few things I've missed so much:\n- type classes\n- super simple metaprogramming through GHC.Generics\n- Trees that Grow that aren't terrible\n- order independent declarations and easy mutual recursion\n- the ability to use data structures other than lists and mutable arrays without massively sacrificing ergonomics."}},{"type":"markdown","markdown":{"content":"I would like to self-host Vega at some point, so it's quite nice that these are all features I've got planned for it anyway. Especially Trees that Grow should be very natural with dependent types."}}],"pinned":false,"commentsLocked":false,"sharesLocked":false,"singlePostPageUrl":"https://cohost.org/prophet/post/3009384-the-vega-programming"}