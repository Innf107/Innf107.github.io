<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Fast Map Union and Local Instances Through Instance Types</title>
    <meta name=viewport content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Fast Map Union and Local Instances Through Instance Types">
    <meta property="og:site_name" content="Prophetlabs">
    <meta property="og:description" content="Fast Map Union and Local Instances Through Instance Types">
    <meta property="twitter:title" content="Fast Map Union and Local Instances Through Instance Types">
    <meta property="twitter:description" content="Fast Map Union and Local Instances Through Instance Types">
    <meta property="twitter:url" content="https://prophetlabs.de/posts/insttypes.html">
    <meta property="twitter:type" content="summary">
    <meta property="twitter:domain" content="prophetlabs.de">
    <meta name="twitter:card" content="summary_large_image">
            <!--Fonts-->
        <link rel="preconnect" href="https://fonts.googleapis.com">
        <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
        <link href="https://fonts.googleapis.com/css2?family=Fira+Code&family=Poppins:wght@400;700&display=swap" rel="stylesheet"> 
        <link rel="stylesheet" type="text/css" href="/assets/post.css">

        <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml">

        <!--Icons-->
        <script src="https://kit.fontawesome.com/e4faccddf2.js" crossorigin="anonymous"></script>

    

    <!--KaTeX-->
<link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"
    integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"
    integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja"
    crossorigin="anonymous"></script>
<!-- Mostly Generated by pandoc -->
<script>
    document.addEventListener("DOMContentLoaded", function () {
        var mathElements = document.getElementsByClassName("math");
        var macros = [];
        for (var i = 0; i < mathElements.length; i++) {
            var texText = mathElements[i].firstChild;
            if (mathElements[i].tagName == "SPAN") {
                katex.render(texText.data, mathElements[i], {
                    displayMode: mathElements[i].classList.contains('display'),
                    throwOnError: false,
                    macros: macros,
                    fleqn: false
                });
            }
        }

        // replace KaTeX colors with CSS variables so that we can control them in light/dark mode
        document.querySelectorAll(".mrel").forEach(element => {
            if (element.style.color == "blue") {
                element.style.color = "var(--katex-blue)"
            } else if (element.style.color == "red") {
                element.style.color = "var(--katex-red)"
            } else if (element.style.color == "purple") {
                element.style.color = "var(--katex-purple)"
            }
        })

        // replace Â¤ characters in source code with '.diff-area' spans and add a '.diff' class to the 
        // corresponding pre element to adjust the style correctly.
        // Ideally this would be done at compile time, but that's more difficult and will not work for katex segments.
        document.querySelectorAll("pre.sourceCode").forEach(pre => {
            let html = pre.innerHTML

            if (!/Â¤/.test(html)) {
                // This code block is not a diff block
                return
            }

            let matchingClosing = false
            while (/Â¤/.test(html)) {
                if (!matchingClosing) {
                    html = html.replace(/Â¤/, "<span class='diff-area'>")
                } else {
                    html = html.replace(/Â¤/, "</span>")
                }

                matchingClosing = !matchingClosing
            }
            if (matchingClosing) {
                console.error("unmatched diff block in source code", pre)
                return
            }

            pre.innerHTML = html
            pre.classList.add("diff")
        })
    })
</script>
    <script>
    document.addEventListener("DOMContentLoaded", function () {
        function reflowGrids() {
            document.querySelectorAll(".grid.parent").forEach(parent => {
                parent.classList.remove("column1")
                let hasOverflow = false
                for (child of parent.children) {
                    // We need to check grandchildren because of how overflow is set up for
                    // code elements
                    for (grandchild of child.children) {
                        // check for horizontal overflow
                        if (grandchild.scrollWidth > grandchild.clientWidth) {
                            hasOverflow = true
                            break
                        }
                    }
                    // Ugh, just give me labelled break
                    if (hasOverflow) {
                        break
                    }
                }
                if (hasOverflow) {
                    parent.classList.add("column1")
                } else {
                    parent.classList.remove("column1")
                }
            })
        }
        reflowGrids()
        window.addEventListener("resize", reflowGrids)
    })
</script>

</head>

<body>
    <header>
    <nav class="navbar">
        <div class="navigation left">
            <a href="/" class="header">Prophetlabs</a>
        </div>
        
        <div class="navigation middle">
        </div>
        <div class="navigation right">
            <button class="dark-mode" onclick="toggleDarkMode()">
                <i id="dark-mode-dark" class="fa-regular fa-moon"></i>
                <span id="dark-mode-light">ðŸ”†</span>
            </button>
            <a href="/about.html">About</a>
        </div>
    </nav>
</header>
    <article>
        <h1>Fast Map Union and Local Instances Through Instance Types</h1>
        <span class="date">26 February 2023</span>
        <p>In part 3<a href="#fn1" class="footnote-ref" id="fnref1"
role="doc-noteref"><sup>1</sup></a> of my <a
href="/posts/unsafeCoerceDict.html">crusade against</a> <a
href="/posts/coherentIP.html">GHCâ€™s coherence guarantees</a>, I have
actually done it! This time we will end up with a way to generate local
type class instances without any asterisks about code breaking with
optimizations. On the way, we are going to end up solving the dreaded
Fast Map Union Problem, combining two of my favorite Haskell tricks, and
discovering a bug in a previous version of GHC.</p>
<p>But before we get to that, letâ€™s start at the beginning</p>
<h2 id="what-even-is-this-fast-map-union-problem">What even is this
â€˜fast Map union problemâ€™?</h2>
<p>Letâ€™s pretend that Haskell <em>did</em> have consistent locally
overridable type class instances. In that case, the interface for
<code>Map</code> would be completely broken.</p>
<p>Look at the type of <code>Data.Map.insert</code></p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">Ord</span> k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v</span></code></pre></div>
<p>See the issue? <code>Map</code> is some kind of ordered tree
internally, so it depends on the <code>Ord</code> instance being
consistent across different operations, but with local instances, we
donâ€™t have any guarantees like that.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- This uses the regular instance for Ord Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="fu">map</span> <span class="ot">=</span> insert (<span class="dv">1</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="dv">1</span> <span class="fu">mempty</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a><span class="co">-- This uses a different, incompatible instance on the same map!</span></span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>withLocalOrd reverseOrdInt <span class="op">$</span> insert (<span class="dv">2</span><span class="ot"> ::</span> <span class="dt">Int</span>) <span class="dv">2</span> <span class="fu">map</span> </span></code></pre></div>
<p>If you think about this for a bit, you may come up with a solution:
You can store the instance in the map. This is how most map
implementations in other languages work after all.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Map</span> k v <span class="ot">=</span> <span class="dt">MkMap</span> (<span class="dt">Dict</span> (<span class="dt">Ord</span> k)) (<span class="dt">ActualMapImplementation</span> k v)</span></code></pre></div>
<p>And now the type of insert doesnâ€™t mention <code>Ord</code> at all
anymore so everything is sunshine and roses</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v</span></code></pre></div>
<p>â€¦until it isnâ€™t! Consider the type of <code>union</code> now</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v <span class="ot">-&gt;</span> <span class="dt">Map</span> k v</span></code></pre></div>
<p>What happens if both maps use different <code>Ord k</code> instances?
We have no way to statically ensure that they donâ€™t. The way to solve
this in practice would be to just reinsert every value from one map in
the other, but that means that union is now drastically slower than it
would be if we could assume that both maps use the same instance (Itâ€™s
now at least linear in the size of one map vs.Â logarithmic in that of
the smaller one).</p>
<h2 id="instance-types">Instance Types</h2>
<p>Now, what we really need here is a way to statically ensure that both
maps use the same <code>Ord</code> implementation. In a dependently
typed language, one could just carry the instance dictionary in the
type</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">Map</span> k v (<span class="ot">inst ::</span> <span class="dt">Ord</span> k) <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> <span class="dt">Map</span> k v inst <span class="ot">-&gt;</span> <span class="dt">Map</span> k v inst <span class="ot">-&gt;</span> <span class="dt">Map</span> k v inst</span></code></pre></div>
<p>But we cannot do that in Haskell (yet?), so we need a few more
tricks. What we absolutely <em>need</em> to do is to somehow move the
used instance to the type level, so letâ€™s start there. While we cannot
directly depend on the instance value, we can define a dummy type as a
stand-in.</p>
<p>With this new type, we can write a version of <code>Ord</code> that
carries its concrete instance in the type. Every function with an
<code>Ord</code> constraint should now be polymorphic over this instance
parameter.</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> <span class="dt">OrdI</span> inst a <span class="op">|</span> inst <span class="ot">-&gt;</span> a <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    compareI ::</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">RegularOrdInt</span></span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">OrdI</span> <span class="dt">RegularOrdInt</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a>    compareI <span class="ot">=</span> <span class="fu">compare</span></span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">ReverseOrdInt</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">OrdI</span> <span class="dt">ReverseOrdInt</span> <span class="dt">Int</span> <span class="kw">where</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    compareI x y <span class="ot">=</span> <span class="kw">case</span> <span class="fu">compare</span> x y <span class="kw">of</span></span>
<span id="cb7-11"><a href="#cb7-11" aria-hidden="true" tabindex="-1"></a>        <span class="dt">LT</span> <span class="ot">-&gt;</span> <span class="dt">GT</span></span>
<span id="cb7-12"><a href="#cb7-12" aria-hidden="true" tabindex="-1"></a>        <span class="dt">EQ</span> <span class="ot">-&gt;</span> <span class="dt">EQ</span></span>
<span id="cb7-13"><a href="#cb7-13" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="dt">LT</span></span></code></pre></div>
<p>And now we can finally parameterize Map over the used
<code>Ord</code> instance!</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">IMap</span> inst k v <span class="ot">=</span> <span class="op">...</span></span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a><span class="ot">insert ::</span> <span class="dt">OrdI</span> inst k <span class="ot">=&gt;</span> k <span class="ot">-&gt;</span> v <span class="ot">-&gt;</span> <span class="dt">IMap</span> inst k v <span class="ot">-&gt;</span> <span class="dt">IMap</span> inst k v</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a><span class="ot">union ::</span> <span class="dt">OrdI</span> inst k <span class="ot">=&gt;</span> <span class="dt">IMap</span> inst k v <span class="ot">-&gt;</span> <span class="dt">IMap</span> inst k v <span class="ot">-&gt;</span> <span class="dt">IMap</span> inst k v</span></code></pre></div>
<p><code>union</code> statically ensures that both maps agree on their
instances.</p>
<p>The only â€˜issueâ€™ here is that we lose some inference. This is more or
less unavoidable if we want multiple instances to coexist (well, more on
that later). We need to tell Haskell what instance to use at some point,
but itâ€™s not that bad, since at least for <code>IMap</code>s, which
carry the instance in their type, we only need to do this once.</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map1 <span class="ot">=</span> insert <span class="dv">1</span> <span class="dv">1</span> <span class="op">$</span> insert <span class="dv">2</span> <span class="dv">2</span> <span class="op">$</span> empty <span class="op">@</span><span class="dt">RegularOrdInt</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> map2 <span class="ot">=</span> insert <span class="op">@</span><span class="dt">ReverseOrdInt</span> <span class="dv">3</span> <span class="dv">3</span> <span class="op">$</span> insert <span class="dv">4</span> <span class="dv">4</span> <span class="op">$</span> empty</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>union map1 map2 <span class="co">-- Type error: Couldn&#39;t match type &#39;RegularOrdInt&#39; with `ReverseOrdInt`</span></span></code></pre></div>
<h2 id="how-do-local-instances-fit-into-this">How do local instances fit
into this?</h2>
<p>Quite well as it turns out! We can combine two of my favorite Haskell
tricks to implement them in current Haskell (You can stop pretending
that they exist. We are going to implement them for real now)</p>
<p>Local instances might differ between different executions of the same
code, so we need to make sure that the instance types can only be used
locally and cannot escape. If this sounds familiar that is because there
is a decent chance that you have used something similar before: <a
href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Control-Monad-ST.html#v:runST"><code>runST</code></a>.</p>
<p><code>ST</code> is a monad that is used for local mutability inside
pure code. You can use it to create <code>STRef</code>s and mutate them,
just like you would in your favorite imperative language<a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>,
except that Haskell, by virtue of being a pure language, needs to make
absolutely sure that you never ever return an <code>STRef</code> from
<code>runST</code>. Doing so would allow effects in one usage of the
supposedly pure <code>runST</code> to affect the result of another
one.</p>
<p>How does <code>ST</code> do this? It uses higher-rank types!</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="ot">newSTRef ::</span> a <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">STRef</span> s a)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a><span class="ot">runST ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>If you have never seen this before, youâ€™re probably quite confused
right now. The type <code>forall s. ST s a</code> specifies that the
argument to <code>runST</code> needs to be an <code>ST</code> value that
works for any possible instantiation of <code>s</code>. Crucially for
this case, this means that the <code>s</code> variable is, unlike
<code>a</code>, <em>not</em> a type parameter of <code>runST</code>
itself, but actually one of <em>the arguments to runST</em>. This is
much clearer if we write <code>runST</code> with an explicit outer
<code>forall</code>.</p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runST ::</span> <span class="kw">forall</span> a<span class="op">.</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a</span></code></pre></div>
<p>Now, the reason this ensures that no STRefs escape is that the
<code>s</code> parameter of the <code>STRef</code> is the same as that
of the containing <code>ST</code> monad. If you <em>were</em> able to
return an <code>STRef</code> from the argument to <code>runST</code>,
e.g.Â by passing something of type
<code>forall s. ST s (STRef s Int)</code>, what type would the result
have? Blindly substituting would yield <code>STRef s Int</code>, but
what is <code>s</code> now? Previously, <code>s</code> was bound by the
<code>forall</code> in the type of the argument to <code>runST</code>,
but that <code>forall</code> does not exist anymore! This is why GHC
will not accept this code and complain about an â€˜escaping skolemâ€™.</p>
<p>We can use exactly the same trick for local type class instances to
invent an instance type that only exists locally! If we can implement a
function of the following type, then this will ensure that instance
types cannot possibly escape.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withOrdI ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (<span class="kw">forall</span> inst<span class="op">.</span> <span class="dt">OrdI</span> inst a <span class="ot">=&gt;</span> b) <span class="ot">-&gt;</span> b</span></code></pre></div>
<p>Now, how do we implement this function? If you read <a
href="/posts/unsafeCoerceDict.html">the first post in this series</a>,
you will probably know the answer already.</p>
<p>At runtime, GHC represents type classes via a technique called
dictionary passing. This means that a function with an <code>Ord</code>
constraint like <code>Ord a =&gt; a -&gt; a -&gt; Ordering</code> will
be turned into a function that <em>takes an implementation of that type
class as an argument</em> (<code>Ord a -&gt; a -&gt; a</code>). This
implementation, called a dictionary, is just a regular record-like data
type that contains an implementation for every method.</p>
<p>Using <code>GADT</code>s, we can capture this dictionary in a
value.</p>
<div class="sourceCode" id="cb13"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OrdIDict</span> a <span class="kw">where</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OrdIDict</span><span class="ot"> ::</span> <span class="dt">Ord</span> a <span class="ot">=&gt;</span> <span class="dt">OrdIDict</span> a</span></code></pre></div>
<p>If we are now able to replicate the structure of this
<code>OrdIDict</code> exactly, but with a custom record of methods, we
can use <code>unsafeCoerce</code> to convert it to a functional
<code>OrdIDict a</code>. By pattern matching on the result, we can
release the dictionary back into a regular instance, which now contains
our handwritten type class instance!</p>
<p>Instinctively, your definition of <code>OrdIDict</code> would
probably look like this</p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OrdIDict</span> inst a <span class="kw">where</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OrdIDict</span><span class="ot"> ::</span> <span class="dt">OrdI</span> inst a <span class="ot">=&gt;</span> <span class="dt">OrdIDict</span> inst a</span></code></pre></div>
<p>This is not going to work though. We need to invent a new type for
<code>inst</code>, so <code>OrdIDict</code> cannot take it as a
parameter. Thanks to Haskellâ€™s support for existential types, this is
not actually an issue, since we can just leave it off<a href="#fn3"
class="footnote-ref" id="fnref3"
role="doc-noteref"><sup>3</sup></a>.</p>
<div class="sourceCode" id="cb15"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">OrdIDict</span> a <span class="kw">where</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>    <span class="dt">OrdIDict</span><span class="ot"> ::</span> <span class="dt">OrdI</span> inst a <span class="ot">=&gt;</span> <span class="dt">OrdIDict</span> a</span></code></pre></div>
<p><code>OrdI</code> only has a single method, so it will be represented
by the equivalent of a newtype record at runtime. This is erased
entirely, so we do not need to build a record around our
<code>a -&gt; a -&gt; Ordering</code> function.</p>
<p>The <code>OrdIDict</code> wrapper adds some indirection though, so we
need to replicate that.</p>
<div class="sourceCode" id="cb16"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">FakeDict</span> a <span class="ot">=</span> <span class="dt">FakeDict</span> a</span></code></pre></div>
<p>All preparations are complete. We are ready for the magic<a
href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a>!</p>
<div class="sourceCode" id="cb17"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withOrdI ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (<span class="kw">forall</span> inst<span class="op">.</span> <span class="dt">OrdI</span> inst a <span class="ot">=&gt;</span> b) <span class="ot">-&gt;</span> b</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>withOrdI dict body <span class="ot">=</span> </span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> unsafeCoerce (<span class="dt">FakeDict</span> dict)<span class="ot"> ::</span> <span class="dt">OrdIDict</span> a <span class="kw">of</span></span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">OrdIDict</span> <span class="op">@</span>inst) <span class="ot">-&gt;</span> body <span class="op">@</span>inst</span></code></pre></div>
<p>And thatâ€™sâ€¦ it!</p>
<p>Well, not quite. If you paid very close attention, you may notice
that we have no way to bind the <code>inst</code> type variable in the
<code>(forall inst. OrdI inst a =&gt; b)</code> argument. This means if
we put a lambda there, we cannot actually mention <code>inst</code>
anywhere. This is easy enough to solve by introducing a <a
href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Proxy.html#t:Proxy"><code>Proxy</code></a>
value.</p>
<div class="sourceCode" id="cb18"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="ot">withOrdIProxy ::</span> <span class="kw">forall</span> a b<span class="op">.</span> (a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">Ordering</span>) <span class="ot">-&gt;</span> (<span class="kw">forall</span> inst<span class="op">.</span> <span class="dt">OrdI</span> inst a <span class="ot">=&gt;</span> <span class="dt">Proxy</span> inst <span class="ot">-&gt;</span> b) <span class="ot">-&gt;</span> b</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>withOrdIProxy dict body <span class="ot">=</span> </span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> unsafeCoerce (<span class="dt">FakeDict</span> dict)<span class="ot"> ::</span> <span class="dt">OrdIDict</span> a <span class="kw">of</span></span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>        (<span class="dt">OrdIDict</span> <span class="op">@</span>inst) <span class="ot">-&gt;</span> body <span class="op">@</span>inst (<span class="dt">Proxy</span> <span class="op">@</span>inst)</span></code></pre></div>
<h2 id="lets-try-it-out">Letâ€™s try it out!</h2>
<p>We can start with some concrete instances</p>
<div class="sourceCode" id="cb19"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a>map1 <span class="ot">=</span> insert <span class="dv">1</span> <span class="dv">1</span> (empty <span class="op">@</span><span class="dt">Int</span>)</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a>map2 <span class="ot">=</span> insert <span class="dv">2</span> <span class="dv">2</span> (empty <span class="op">@</span><span class="dt">Int</span>)</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>map3 <span class="ot">=</span> insert <span class="dv">3</span> <span class="dv">3</span> (empty <span class="op">@</span><span class="dt">ReverseIntOrd</span>)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>map4 <span class="ot">=</span> insert <span class="dv">4</span> <span class="dv">4</span> (empty <span class="op">@</span><span class="dt">ReverseIntOrd</span>)</span>
<span id="cb19-6"><a href="#cb19-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-7"><a href="#cb19-7" aria-hidden="true" tabindex="-1"></a>fine1 <span class="ot">=</span> union map1 map2</span>
<span id="cb19-8"><a href="#cb19-8" aria-hidden="true" tabindex="-1"></a>fine2 <span class="ot">=</span> union map3 map4</span>
<span id="cb19-9"><a href="#cb19-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-10"><a href="#cb19-10" aria-hidden="true" tabindex="-1"></a>notFine <span class="ot">=</span> union map1 map3 <span class="co">-- fails!</span></span></code></pre></div>
<p>Looking good. Now letâ€™s try local instances</p>
<div class="sourceCode" id="cb20"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>local <span class="ot">=</span> withOrdIProxy <span class="fu">compare</span> \(<span class="dt">Proxy</span> <span class="op">@</span>inst) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span><span class="ot"> localMap1 ::</span> <span class="dt">IMap</span> inst <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">=</span> insert <span class="op">@</span>inst <span class="dv">1</span> <span class="dv">1</span> (empty <span class="op">@</span>inst)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>    ()</span></code></pre></div>
<div class="sourceCode" id="cb21"><pre
class="sourceCode bash"><code class="sourceCode bash"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> ghc-9.2 insttypes.hs</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="ex">insttypes.hs:80:42:</span> error:</span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a>    <span class="ex">â€¢</span> Could not deduce <span class="er">(</span><span class="ex">OrdI</span> <span class="er">(</span><span class="ex">*</span><span class="kw">)</span> <span class="ex">Int</span><span class="kw">)</span> <span class="ex">arising</span> from a use of â€˜insertâ€™</span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>      <span class="ex">from</span> the context: OrdI inst a0</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>    <span class="ex">...</span></span></code></pre></div>
<p>Huh. That isâ€¦ strange. It looks like for some strange reason, GHC
defaults the <code>inst</code> parameter toâ€¦ <code>(*)</code><a
href="#fn5" class="footnote-ref" id="fnref5"
role="doc-noteref"><sup>5</sup></a>? Even if we add as many type
annotations as physically possible?</p>
<p>If this smells like a bug in GHC, that is <strong>because it
is!</strong> Or well, <em>was</em>.</p>
<p>If you run the same example with GHC 9.4, it will compile without
complaining.</p>
<p>Now, letâ€™s try that again</p>
<div class="sourceCode" id="cb22"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>local <span class="ot">=</span> withOrdIProxy <span class="fu">compare</span> \(<span class="dt">Proxy</span> <span class="op">@</span>inst) <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> localMap1 <span class="ot">=</span> insert <span class="dv">1</span> <span class="dv">1</span> (empty <span class="op">@</span>inst)</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> localMap2 <span class="ot">=</span> insert <span class="dv">2</span> <span class="dv">2</span> (empty <span class="op">@</span>inst)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> perfectlyFine <span class="ot">=</span> union localMap1 localMap2</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span><span class="ot"> notFine ::</span> <span class="dt">IMap</span> <span class="dt">RegularIntOrd</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">=</span> insert <span class="op">@</span>inst <span class="dv">2</span> <span class="dv">2</span> (empty <span class="op">@</span>inst) <span class="co">-- fails!</span></span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> notFine2 <span class="ot">=</span> union localMap1 map1 <span class="co">-- also fails!</span></span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>    localMap1 <span class="co">-- fails!</span></span></code></pre></div>
<p>Perfect!</p>
<h3 id="do-we-have-to-annotate-the-instance-every-time">Do we have to
annotate the instance every time?</h3>
<p>In this specific example with <code>IMap</code>, the number of type
annotations required was quite manageable, but in code that uses
<code>OrdI</code> like regular <code>Ord</code>, this is much less
pleasant</p>
<div class="sourceCode" id="cb23"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="ot">min3 ::</span> <span class="dt">IOrd</span> inst a <span class="ot">=&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>min3 x y z <span class="ot">=</span> <span class="kw">case</span> <span class="fu">compare</span> <span class="op">@</span>inst x y <span class="kw">of</span> <span class="co">-- needs a type application!</span></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="fu">compare</span> <span class="op">@</span>inst y z <span class="kw">of</span> <span class="co">-- this one as well</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GT</span> <span class="ot">-&gt;</span> z</span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> y</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    _ <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="fu">compare</span> <span class="op">@</span>inst x z <span class="kw">of</span> <span class="co">-- same here</span></span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">GT</span> <span class="ot">-&gt;</span> <span class="kw">case</span> <span class="fu">compare</span> <span class="op">@</span>inst y z <span class="kw">of</span> <span class="co">-- also here</span></span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a>            <span class="dt">GT</span> <span class="ot">-&gt;</span> z</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>            _ <span class="ot">-&gt;</span> y</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>        _ <span class="ot">-&gt;</span> x</span></code></pre></div>
<p>Used directly like this, this technique is really just <a
href="https://www.haskellforall.com/2012/05/scrap-your-type-classes.html">Scrap
your type classes</a> with extra steps.</p>
<p>This is frustrating because we are just running up against GHCâ€™s
stubbornness here. There is only a single possible instance for
<code>IOrd inst a</code> in scope, but GHC doesnâ€™t want to choose it.
Usually, this behavior might make sense, but itâ€™s really not helpful for
us.</p>
<p>Fortunately for us though, we are not the first to run into this
issue! <a
href="https://hackage.haskell.org/package/polysemy">Polysemy</a>, the
popular effect system library, had the exact same problem. Polysemy
makes it possible to define effects of the form
<code>Member Effect r</code> over a set of effects <code>r</code>. The
issue here is that, unlike <a
href="https://hackage.haskell.org/package/mtl">mtl</a>, Polysemy allows
duplicate effects, so GHC again doesnâ€™t trust that you really wanted to
use the constraint from the signature and not another, currently
unwritten one.</p>
<p>How did Polysemy solve that? They wrote <a
href="https://hackage.haskell.org/package/polysemy-plugin">a type
checker plugin</a> that disambiguates Polysemy constraints whenever
there is exactly one relevant instance in scope.</p>
<p>This is exactly what we want, so we could probably copy most of
it.</p>
<p>But that is a topic for a future blog post.</p>
<h2 id="conclusion">Conclusion</h2>
<p>We covered quite a bit of ground there.</p>
<ul>
<li>We parameterized type classes over a type representing the
instance</li>
<li>This made it possible to statically ensure that maps can safely be
merged in logarithmic time, even in the presence of local instances</li>
<li>We managed to implement local type class instances that are actually
safe, even in the presence of optimizations</li>
<li>We discovered a bug in GHC 9.2</li>
<li>There is probably a way to avoid unnecessary type applications with
a GHC plugin</li>
</ul>
<p>This is the first time in this series that I can write a conclusion
without begging you to â€˜please never ever use this anywhere near
productionâ€™. This technique still relies on GHCâ€™s internal type class
representation (and you should always be careful around
<code>unsafeCoerce</code>) but so does the popular <a
href="https://hackage.haskell.org/package/reflection">reflection</a>
package, so you should be fine.</p>
<p>If you want to try this for yourself, you can get the code <a
href="https://gist.github.com/Innf107/53f1b6e2fdbb1ca0a49d1f75375c036c">in
a gist</a>. Just make sure to use GHC 9.4 or above.</p>
<aside id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>You donâ€™t need to have read any of the previous posts to
understand this, donâ€™t worry. On the other hand, if you like this one,
you will probably enjoy the others as well ;)<a href="#fnref1"
class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn2"><p>If your favorite imperative language is OCaml or
Standard ML that is.<a href="#fnref2" class="footnote-back"
role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn3"><p>In fact, pattern matching on a value containing an
existentially quantified type variable will turn that variable into a
â€˜skolemâ€™, just like the higher rank type in the <code>runST</code>
example, so we are truly conjuring a new type from thin air with this.<a
href="#fnref3" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn4"><p>This is an OCaml joke. Donâ€™t worry about it.<a
href="#fnref4" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
<li id="fn5"><p><code>(*)</code> is another way of writing <a
href="https://hackage.haskell.org/package/base-4.17.0.0/docs/Data-Kind.html#t:Type"><code>Type</code></a>,
the type of types. The only reason this is even valid is that modern GHC
Haskell has dependent kinds and <code>Type : Type</code>.<a
href="#fnref5" class="footnote-back" role="doc-backlink">â†©ï¸Ž</a></p></li>
</ol>
</aside>
        <hr>
        If you want to tell me your thoughts about this post, you can leave a comment on <a href="https://www.reddit.com/r/haskell/comments/11c27fh/fast_map_union_and_local_instances_through/">Reddit</a>
        or <a href="/about.html">contact me directly</a>.
        <script src="/js/main.js"></script>
    </article>
</body>

</html>