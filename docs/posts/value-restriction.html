<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>Violating memory safety with Haskell's value restriction</title>
    <meta name=viewport content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="Violating memory safety with Haskell's value restriction">
    <meta property="og:site_name" content="welltypedwit.ch">
    <meta property="og:description" content="Violating memory safety with Haskell's value restriction">
    <meta property="twitter:title" content="Violating memory safety with Haskell's value restriction">
    <meta property="twitter:description" content="Violating memory safety with Haskell's value restriction">
    <meta property="twitter:url" content="https://welltypedwit.ch/posts/value-restriction.html">
    <meta property="twitter:type" content="summary">
    <meta property="twitter:domain" content="welltypedwit.ch">
    <meta name="twitter:card" content="summary_large_image">
    <!--Fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600;700&family=Inria+Sans:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/css/main.css">

    <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml">

    <!--Icons-->
    <script src="https://kit.fontawesome.com/e4faccddf2.js" crossorigin="anonymous"></script>



    <!--KaTeX-->
    <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"
        integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"
        integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja"
        crossorigin="anonymous"></script>
    <!-- Mostly Generated by pandoc -->
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var mathElements = document.getElementsByClassName("math");
            var macros = [];
            for (var i = 0; i < mathElements.length; i++) {
                var texText = mathElements[i].firstChild;
                if (mathElements[i].tagName == "SPAN") {
                    katex.render(texText.data, mathElements[i], {
                        displayMode: mathElements[i].classList.contains('display'),
                        throwOnError: false,
                        macros: macros,
                        fleqn: false
                    });
                }
            }

            // replace KaTeX colors with CSS variables so that we can control them in light/dark mode
            document.querySelectorAll(".mrel").forEach(element => {
                if (element.style.color == "blue") {
                    element.style.color = "var(--katex-blue)"
                } else if (element.style.color == "red") {
                    element.style.color = "var(--katex-red)"
                } else if (element.style.color == "purple") {
                    element.style.color = "var(--katex-purple)"
                }
            })

            // replace ¤ characters in source code with '.diff-area' spans and add a '.diff' class to the 
            // corresponding pre element to adjust the style correctly.
            // Ideally this would be done at compile time, but that's more difficult and will not work for katex segments.
            document.querySelectorAll("pre.sourceCode").forEach(pre => {
                let html = pre.innerHTML

                if (!/¤/.test(html)) {
                    // This code block is not a diff block
                    return
                }

                let matchingClosing = false
                while (/¤/.test(html)) {
                    if (!matchingClosing) {
                        html = html.replace(/¤/, "<span class='diff-area'>")
                    } else {
                        html = html.replace(/¤/, "</span>")
                    }

                    matchingClosing = !matchingClosing
                }
                if (matchingClosing) {
                    console.error("unmatched diff block in source code", pre)
                    return
                }

                pre.innerHTML = html
                pre.classList.add("diff")
            })
        })
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            function reflowGrids() {
                document.querySelectorAll(".grid.parent").forEach(parent => {
                    parent.classList.remove("column1")
                    let hasOverflow = false
                    for (child of parent.children) {
                        // We need to check grandchildren because of how overflow is set up for
                        // code elements
                        for (grandchild of child.children) {
                            // check for horizontal overflow
                            if (grandchild.scrollWidth > grandchild.clientWidth) {
                                hasOverflow = true
                                break
                            }
                        }
                        // Ugh, just give me labelled break
                        if (hasOverflow) {
                            break
                        }
                    }
                    if (hasOverflow) {
                        parent.classList.add("column1")
                    } else {
                        parent.classList.remove("column1")
                    }
                })
            }
            reflowGrids()
            window.addEventListener("resize", reflowGrids)
        })
    </script>

</head>

<body>
    <div class="underline-wrapper">
        <nav class="main-nav">
            <a href="/" class="site-title">welltypedwit.ch</a>
        </nav>
    </div>

    <article class="post">
        <h1 class="post-header">Violating memory safety with Haskell's value restriction</h1>
        <span class="date">17 May 2025</span>
        <p></p>
<p>A common issue in impure ML-style languages with polymorphism and
mutable references is the possibility of <em>polymorphic
references</em>.</p>
<p>In a hypothetical impure language that had both these features, but
no mitigations against polymorphic references, the following code would
be extremely unsafe.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeCoerce ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>unsafeCoerce x <span class="ot">=</span> </span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> dangerous <span class="ot">=</span> ref <span class="dt">Nothing</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>    dangerous <span class="op">:=</span> <span class="dt">Just</span> x</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> dangerous <span class="kw">of</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> y <span class="ot">-&gt;</span> y</span></code></pre></div>
<p>This code creates a reference <code>dangerous</code> with an initial
value of <code>Nothing</code>, writes <code>x</code> to it, and then
reads from it again. But because this language doesn’t prevent
polymorphic references and <code>Nothing</code> has type
<code>forall a. Maybe a</code>, <code>dangerous</code> is actually
<em>generalized</em> to <code>forall a. Ref (Maybe a)</code>. This means
that in the line that writes to it, <code>dangerous</code> is
instantiated to <code>Maybe a</code>, whereas in the line that
<em>reads</em> from it, it is instantiated to <code>Maybe b</code>,
although the value stored in it still has type <code>a</code>, breaking
type safety and consequently memory safety!</p>
<p>Scary, right?</p>
<p>You might think that you could prevent this by just preventing
generalization of reference types, but references can be hidden behind
closures, so languages need a slightly blunter hammer: the <em>value
restriction</em>.</p>
<p>The value restriction says that a let binding can only ever be given
a polymorphic type if its bound expression is syntactically a “value”,
i.e. an expression that obviously will not perform any computation.
<code>5</code> is a value. So is <code>Nothing</code>. But
<code>sqrt 42</code> and (crucially) <code>ref Nothing</code> are
<em>not</em> values and will not be generalized.<a href="#fn1"
class="footnote-ref" id="fnref1" role="doc-noteref"><sup>1</sup></a></p>
<h2
id="haskells-let-bindings-do-not-have-a-value-restriction.">Haskell’s
let bindings do not have a value restriction.</h2>
<p>So, does this mean that Haskell’s type system is deeply unsound and
we just never noticed?</p>
<p>No! If we translate the original example to Haskell, we will hit a
type error, telling us that <code>dangerous</code> was <em>not</em>
generalized.</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeCoerce ::</span> a <span class="ot">-&gt;</span> b</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>unsafeCoerce x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>    dangerous <span class="ot">&lt;-</span> newIORef <span class="dt">Nothing</span></span>
<span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>    writeIORef dangerous (<span class="dt">Just</span> x)</span>
<span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>    result <span class="ot">&lt;-</span> readIORef dangerous</span>
<span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">case</span> result <span class="kw">of</span></span>
<span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span>
<span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> y <span class="ot">-&gt;</span> y</span></code></pre></div>
<!-- ghc output -->
<pre><div style="font-family: "><div><span style="font-weight: bold;">MonadGen.hs:82:19: </span><span style="color: #cd3131; font-weight: bold;">error</span><span style="font-weight: bold;">: [</span><span style="font-weight: bold; text-decoration: underline;">GHC-25897</span><span style="font-weight: bold;">]</span><span>
</span></div><div><span></span><span style="font-weight: bold;">    • Couldn't match type ‘a’ with ‘b’</span></div><div><span></span><span style="font-weight: bold;">      Expected: IO b</span></div><div><span style="font-weight: bold;">        Actual: IO a</span></div></div></pre>
<!-- /ghc output -->
<p>But the interesting question here is: <em>Why</em> was it not
generalized? To answer that, we will have to take a small step back.</p>
<h2 id="what-even-is-an-io">What even is an IO</h2>
<p>The important detail in this Haskell code is that
<code>dangerous</code> was <em>not</em> bound in a <code>let</code>
binding. It was bound in a monadic <code>do</code>-binding.</p>
<p><code>IO</code> is famously a monad, so a <code>do</code>-binding
like this is just syntactic sugar for an application of
<code>(&gt;&gt;=)</code>, which (specialized to <code>IO</code>) has the
following type.</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="ot">(&gt;&gt;=) ::</span> <span class="kw">forall</span> a b<span class="op">.</span> <span class="dt">IO</span> a <span class="ot">-&gt;</span> (a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span></code></pre></div>
<p>So the value passed to the continuation (corresponding to the
variable in the let binding) has whatever type is wrapped
<em>inside</em> the <code>IO</code> type constructor of its first
argument.</p>
<p>Now, <code>newIORef Nothing</code> can itself have a polymorphic
type.</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>newIORef <span class="dt">Nothing</span><span class="ot"> ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">IO</span> (<span class="dt">IORef</span> a)</span></code></pre></div>
<p>However, notice that the polymorphic forall quantifier occurs
<em>outside</em> the <code>IO</code>! This means that the value passed
to the continuation of <code>(newIORef Nothing &gt;&gt;=)</code> will
always have type <code>IORef _</code> and therefore be
<em>monomorphic</em>. We can instantiate the <code>a</code> with
<code>forall a. Maybe a</code>, but that only gives us a perfectly safe
<code>IORef (forall a. Maybe a)</code><a href="#fn2"
class="footnote-ref" id="fnref2" role="doc-noteref"><sup>2</sup></a>,
<em>not</em> a <code>forall a. IORef (Maybe a)</code>.</p>
<p>That’s the magic! The placement of the <code>IO</code> in the types
prevents giving <code>dangerous</code> a polymorphic type.</p>
<p>What I really want you to appreciate here is just how similar this is
to the traditional value restriction. If we’re allowed to do arbitrary
effects, we might create a polymorphic reference, so ML bans all let
bindings that look like they might perform effects, whereas Haskell
already has a distinction between pure and effectful let bindings
(<code>&gt;&gt;=</code>) and just needs to prevent the second group from
being generalized.</p>
<h2 id="generalizable-monads">Generalizable Monads</h2>
<p>This hopefully all seems reasonable so far. <code>IO</code> can
create mutable references so we need to prevent it from generalizing
them and that’s why the monadic interface imposes something resembling
the value restriction.</p>
<p>But… <code>IO</code> is not the only monad. If we look at <a
href="https://hackage.haskell.org/package/base-4.21.0.0/docs/Data-Functor-Identity.html#t:Identity"><code>Identity</code></a>,
it’s a monad that quite literally does nothing, so a
<code>do</code>-binding in <code>Identity</code> is just a pure
<code>let</code>-binding. Shouldn’t we at least be able to generalize
<code>do</code>-bindings in a trivial monad like this?</p>
<p>Let’s think through what that would mean. Above, we couldn’t
generalize <code>newIORef Nothing</code> because it had type
<code>forall a. IO (IORef (Maybe a))</code> with the <code>forall</code>
on the <em>outside</em>. If it had type
<code>IO (forall a. IORef (Maybe a))</code>, we could instantiate the
<code>a</code> parameter to <code>(&gt;&gt;=)</code> with
<code>forall a. IORef (Maybe a)</code> and therefore generalize it.</p>
<p>Coming back to <code>Identity</code>, we can generalize Identity
bindings, if for any context <code>f</code>
(e.g. <code>f ~ IORef</code>), we can turn something of type
<code>forall a. Identity (f a)</code> into something of type
<code>Identity (forall a. f a)</code>. More generally, we can define a
type class for monads where we can generalize bindings this way.</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> (<span class="dt">Monad</span> m) <span class="ot">=&gt;</span> <span class="dt">MonadGen</span> m <span class="kw">where</span></span>
<span id="cb5-2"><a href="#cb5-2" aria-hidden="true" tabindex="-1"></a><span class="ot">    generalize ::</span> <span class="kw">forall</span> f<span class="op">.</span> (<span class="kw">forall</span> a<span class="op">.</span> m (f a)) <span class="ot">-&gt;</span> m (<span class="kw">forall</span> a<span class="op">.</span> f a)</span></code></pre></div>
<p>So, can we define this for Identity? Yes!<a href="#fn3"
class="footnote-ref" id="fnref3" role="doc-noteref"><sup>3</sup></a></p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadGen</span> <span class="dt">Identity</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (<span class="dt">Identity</span> x) <span class="ot">=</span> m</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Identity</span> x</span></code></pre></div>
<p>If we use this new fancy function, our monadic bindings in
<code>Identity</code> can be just as powerful as regular let bindings!
(though a little less convenient since we need newtypes)</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">Endo</span> a <span class="ot">=</span> <span class="dt">Endo</span> (a <span class="ot">-&gt;</span> a)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-3"><a href="#cb7-3" aria-hidden="true" tabindex="-1"></a><span class="ot">applyEndo ::</span> <span class="dt">Endo</span> a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> a</span>
<span id="cb7-4"><a href="#cb7-4" aria-hidden="true" tabindex="-1"></a>applyEndo (<span class="dt">Endo</span> f) x <span class="ot">=</span> f x</span>
<span id="cb7-5"><a href="#cb7-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb7-6"><a href="#cb7-6" aria-hidden="true" tabindex="-1"></a><span class="ot">blah ::</span> <span class="dt">Identity</span> (<span class="dt">Bool</span>, <span class="dt">Char</span>)</span>
<span id="cb7-7"><a href="#cb7-7" aria-hidden="true" tabindex="-1"></a>blah <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb7-8"><a href="#cb7-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">-- f :: forall a. Endo a &lt;- pure (Endo (\x -&gt; x))  -- fails</span></span>
<span id="cb7-9"><a href="#cb7-9" aria-hidden="true" tabindex="-1"></a><span class="ot">    f ::</span> <span class="kw">forall</span> a<span class="op">.</span> <span class="dt">Endo</span> a <span class="ot">&lt;-</span> generalize (<span class="fu">pure</span> (<span class="dt">Endo</span> (\x <span class="ot">-&gt;</span> x))) <span class="co">-- succeeds</span></span>
<span id="cb7-10"><a href="#cb7-10" aria-hidden="true" tabindex="-1"></a>    <span class="fu">pure</span> (applyEndo f <span class="dt">True</span>, applyEndo f <span class="ch">&#39;a&#39;</span>)</span></code></pre></div>
<p>Nice! Since we made this a type class, you’re probably already
wondering which other monads we can implement it for. Turns out, there
are actually quite a few! For reasons that will become apparent in a
moment, let’s look at…</p>
<h2 id="statestate">State<a href="#fn4" class="footnote-ref" id="fnref4"
role="doc-noteref"><sup>4</sup></a></h2>
<p>The <code>State</code> monad in Haskell is defined as<a href="#fn5"
class="footnote-ref" id="fnref5" role="doc-noteref"><sup>5</sup></a></p>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">State</span> s a <span class="ot">=</span> <span class="dt">State</span> (s <span class="ot">-&gt;</span> (s, a))</span></code></pre></div>
<p>In order to simulate mutable state, this definition represents
computations as functions that take the current state as a parameter and
return a new state value. As it turns out, if we just keep plumbing
those state values around, nothing stops us from binding the result of
this function in a let binding and thereby generalizing the result of
the computation!</p>
<div class="sourceCode" id="cb9"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadGen</span> (<span class="dt">State</span> s) <span class="kw">where</span></span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (<span class="dt">State</span> f) <span class="ot">=</span> m</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">State</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (s&#39;, result) <span class="ot">=</span> f s</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a>            (s&#39;, result)</span></code></pre></div>
<p>Great! So it seems like many pure monads do support binding
generalization. Then there must be something about the internal
structure of <code>IO</code> that is somehow special and prevents us
from implementing <code>MonadGen IO</code>, right?</p>
<p>Right?</p>
<h2 id="what-is-an-io-really">What is an IO, <em>really</em>?</h2>
<p>A popular metaphor for impure functions in pure languages is that
instead of modifying the world around it, a function like
<code>putStrLn</code> essentially takes the real world as a parameter
and returns a modified version of it where a string has been written to
<code>stdout</code>. Interestingly enough, this is very close to how
<code>IO</code> works internally!</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">IO</span> a <span class="ot">=</span> <span class="dt">IO</span> (<span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span> <span class="ot">-&gt;</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> <span class="dt">RealWorld</span>, a <span class="op">#</span>))</span></code></pre></div>
<p>Of course, we cannot literally modify the real world as a pure value,
so internally, <code>putStrLn</code> is an actual, impure function.</p>
<p>But the <code>State#</code> values still act both as capabilities
(ensuring that impure functions can only be called from impure
functions) and data dependencies (to ensure that impure functions are
evaluated in the correct order despite laziness).</p>
<p>Using this constructor directly can be unsafe, since the illusion of
purely modifying the real world (and <code>IO</code>’s sequencing
guarantees) only apply if the <code>State# RealWorld</code> tokens are
passed around <em>linearly</em>, i.e. are never duplicated or dropped.
However, if we manually make sure to uphold this invariant and we don’t
use any further GHC internals, common knowledge suggests that we should
be safe.</p>
<h2 id="that-type-definition-looks-familiar">That type definition looks
familiar</h2>
<p>It uses an unboxed tuple instead of a boxed one and is specialized to
(zero-sized) unboxed <code>State# RealWorld</code> tokens, but otherwise
<code>IO</code> is really just a state monad! So, if we were able to
implement <code>MonadGen</code> for <code>State</code>, shouldn’t we be
able to implement it for <code>IO</code> as well?</p>
<p>If we tried to copy the <code>State</code> definition directly, we
would hit a quite awkwardly phrased error message<a href="#fn6"
class="footnote-ref" id="fnref6" role="doc-noteref"><sup>6</sup></a></p>
<div class="sourceCode" id="cb11"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadGen</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>    generalize m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (<span class="dt">IO</span> f) <span class="ot">=</span> m</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a>        <span class="dt">IO</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (<span class="op">#</span> s&#39;, result <span class="op">#</span>) <span class="ot">=</span> f s</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a>            (<span class="op">#</span> s&#39;, result <span class="op">#</span>)</span></code></pre></div>
<pre><div style="font-family: "><div><span></span><span style="font-weight: bold;">MonadGen.hs:51:17: </span><span style="color: #cd3131; font-weight: bold;">error</span><span style="font-weight: bold;">: [</span><span style="font-weight: bold; text-decoration: underline;">GHC-20036</span><span style="font-weight: bold;">]</span></div><div><span></span><span style="font-weight: bold;">    You can't mix polymorphic and unlifted bindings:</span></div><div><span></span><span style="font-weight: bold;">      (# s', result #) = f s</span></div><div><span style="font-weight: bold;">    Suggested fix: Add a type signature.</span></div></div></pre>
<p>Unfortunately, the suggested fix doesn’t help us. Giving
<code>result</code> a polymorphic type is the whole point here!</p>
<p>Fortunately, we can just box the <code>State# RealWorld</code> token
first and avoid the issue.</p>
<div class="sourceCode" id="cb12"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">BoxedState</span> s <span class="ot">=</span> <span class="dt">BoxedState</span> {<span class="ot">state ::</span> <span class="dt">State</span><span class="op">#</span> s}</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-3"><a href="#cb12-3" aria-hidden="true" tabindex="-1"></a><span class="ot">liftState ::</span> (<span class="op">#</span> <span class="dt">State</span><span class="op">#</span> s, b <span class="op">#</span>) <span class="ot">-&gt;</span> (<span class="dt">BoxedState</span> s, b)</span>
<span id="cb12-4"><a href="#cb12-4" aria-hidden="true" tabindex="-1"></a>liftState (<span class="op">#</span> s, b <span class="op">#</span>) <span class="ot">=</span> (<span class="dt">BoxedState</span> s, b)</span>
<span id="cb12-5"><a href="#cb12-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb12-6"><a href="#cb12-6" aria-hidden="true" tabindex="-1"></a><span class="kw">instance</span> <span class="dt">MonadGen</span> <span class="dt">IO</span> <span class="kw">where</span></span>
<span id="cb12-7"><a href="#cb12-7" aria-hidden="true" tabindex="-1"></a>    generalize m <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb12-8"><a href="#cb12-8" aria-hidden="true" tabindex="-1"></a>        <span class="kw">let</span> (<span class="dt">IO</span> f) <span class="ot">=</span> m</span>
<span id="cb12-9"><a href="#cb12-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">IO</span> \s <span class="ot">-&gt;</span> <span class="kw">do</span></span>
<span id="cb12-10"><a href="#cb12-10" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (boxedState, result) <span class="ot">=</span> liftState (f s)</span>
<span id="cb12-11"><a href="#cb12-11" aria-hidden="true" tabindex="-1"></a>            <span class="kw">let</span> (<span class="dt">BoxedState</span>{state}) <span class="ot">=</span> boxedState</span>
<span id="cb12-12"><a href="#cb12-12" aria-hidden="true" tabindex="-1"></a>            (<span class="op">#</span> state, result <span class="op">#</span>)</span></code></pre></div>
<p>And this compiles! So, does that mean…</p>
<h2 id="yes">Yes!</h2>
<div class="sourceCode" id="cb13"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">MaybeRef</span> a <span class="ot">=</span> <span class="dt">MaybeRef</span> (<span class="dt">IORef</span> (<span class="dt">Maybe</span> a))</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a><span class="ot">unsafeCoerceIO ::</span> <span class="kw">forall</span> a b<span class="op">.</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>unsafeCoerceIO x <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    maybeRef <span class="ot">&lt;-</span> generalize (<span class="dt">MaybeRef</span> <span class="op">&lt;$&gt;</span> newIORef <span class="dt">Nothing</span>)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">let</span> <span class="dt">MaybeRef</span> ref <span class="ot">=</span> maybeRef</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>    writeIORef ref (<span class="dt">Just</span> x)</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>    readIORef ref <span class="op">&gt;&gt;=</span> \<span class="kw">case</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Just</span> y <span class="ot">-&gt;</span> <span class="fu">pure</span> y</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> <span class="fu">error</span> <span class="st">&quot;unreachable&quot;</span></span></code></pre></div>
<p><span></span></p>
<div class="sourceCode" id="cb14"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>λ<span class="op">&gt;</span> unsafeCoerceIO <span class="op">@</span>_ <span class="op">@</span><span class="dt">String</span> <span class="fu">id</span></span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a><span class="st">&quot;fish: Job 1, &#39;ghci MonadGen.hs&#39; terminated by signal SIGSEGV (Address boundary error)</span></span></code></pre></div>
<h2 id="conclusion">Conclusion</h2>
<p>What I want you to take away from this is that</p>
<ul>
<li>Despite its purity, Haskell <em>does</em> need something resembling
the value restriction, just like every other ML with references.</li>
<li>However, this value restriction is only given by the monadic
interface of <code>IO</code> and <em>not</em> inherent to its
definition.</li>
<li>Contrary to popular belief, unwrapping the <code>IO</code>
constructor is deeply unsafe and can violate memory safety, even if
<code>State#</code> tokens are never duplicated or dropped.</li>
</ul>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>This is quite a strong restriction, so languages like
OCaml use <a
href="https://caml.inria.fr/pub/papers/garrigue-value_restriction-fiwflp04.pdf">a
slightly more flexible approach</a>. The core idea of restricting
generalization of function calls that don’t clearly return values that
are safe to generalize remains though.<a href="#fnref1"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn2"><p>It’s just a reference that can only store values of the
form <code>Nothing</code>, <code>Just undefined</code> or
<code>undefined</code>.<a href="#fnref2" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn3"><p>Even though it looks a little strange, the let binding
to bind <code>Identity x</code> is necessary! Directly matching on
<code>m</code> wouldn’t allow it to be generalized. This also relies on
<code>MonoLocalBinds</code> (implied by <code>TypeFamilies</code>,
<code>GADTs</code> and <code>LinearTypes</code>) being off for this
module, since that would prevent generalization of the let binding that
mentions a variable from an outer scope.<a href="#fnref3"
class="footnote-back" role="doc-backlink">↩︎</a></p></li>
<li id="fn4"><p>If you know a little about GHC internals, you might see
where I’m going with this.<a href="#fnref4" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn5"><p>The <a
href="https://hackage-content.haskell.org/package/transformers-0.6.2.0/docs/Control-Monad-Trans-State-Strict.html#t:State">actual
definition</a> in <code>transformers</code> is a type synonym for
<code>StateT Identity</code>. It’s possible to define a
<code>MonadGen</code> instance for <code>StateT m</code> (provided
<code>m</code> implements <code>MonadGen</code>), but that only detracts
from the main point, so we will use the non-transformer
<code>State</code>. I’ve also changed the argument order to make it a
little more sensible.<a href="#fnref5" class="footnote-back"
role="doc-backlink">↩︎</a></p></li>
<li id="fn6"><p>That’s how you know you’re using the fun parts of GHC<a
href="#fnref6" class="footnote-back" role="doc-backlink">↩︎</a></p></li>
</ol>
</section>
    </article>
</body>

</html>