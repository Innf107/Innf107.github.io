<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <title>runST does not prevent resources from escaping</title>
    <meta name=viewport content="width=device-width, initial-scale=1.0">
    <meta property="og:title" content="runST does not prevent resources from escaping">
    <meta property="og:site_name" content="welltypedwit.ch">
    <meta property="og:description" content="runST does not prevent resources from escaping">
    <meta property="og:image" content="https://welltypedwit.ch/opengraph/posts/runst-does-not-prevent-resources-from-escaping.png">
    <meta property="twitter:title" content="runST does not prevent resources from escaping">
    <meta property="twitter:description" content="runST does not prevent resources from escaping">
    <meta property="twitter:url" content="https://welltypedwit.ch/posts/runst-does-not-prevent-resources-from-escaping.html">
    <meta property="twitter:type" content="summary">
    <meta property="twitter:domain" content="welltypedwit.ch">
    <meta name="twitter:card" content="summary_large_image">
    <!--Fonts-->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Fira+Code:wght@400;600;700&family=Inria+Sans:wght@400;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" type="text/css" href="/css/main.css">

    <link rel="alternate" type="application/rss+xml" title="RSS Feed" href="/rss.xml">

    <!--Icons-->
    <script src="https://kit.fontawesome.com/e4faccddf2.js" crossorigin="anonymous"></script>



    <!--KaTeX-->
    <link defer rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css"
        integrity="sha384-Xi8rHCmBmhbuyyhbI88391ZKP2dmfnOl4rT9ZfRI7mLTdk1wblIUnrIq35nqwEvC" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"
        integrity="sha384-X/XCfMm41VSsqRNQgDerQczD69XqmjOOOwYQvr/uuC+j4OPoNhVgjdGFwhvN02Ja"
        crossorigin="anonymous"></script>
    <!-- Mostly Generated by pandoc -->
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            var mathElements = document.getElementsByClassName("math");
            var macros = [];
            for (var i = 0; i < mathElements.length; i++) {
                var texText = mathElements[i].firstChild;
                if (mathElements[i].tagName == "SPAN") {
                    katex.render(texText.data, mathElements[i], {
                        displayMode: mathElements[i].classList.contains('display'),
                        throwOnError: false,
                        macros: macros,
                        fleqn: false
                    });
                }
            }

            // replace KaTeX colors with CSS variables so that we can control them in light/dark mode
            document.querySelectorAll(".mrel").forEach(element => {
                if (element.style.color == "blue") {
                    element.style.color = "var(--katex-blue)"
                } else if (element.style.color == "red") {
                    element.style.color = "var(--katex-red)"
                } else if (element.style.color == "purple") {
                    element.style.color = "var(--katex-purple)"
                }
            })

            // replace ¬§ characters in source code with '.diff-area' spans and add a '.diff' class to the 
            // corresponding pre element to adjust the style correctly.
            // Ideally this would be done at compile time, but that's more difficult and will not work for katex segments.
            document.querySelectorAll("pre.sourceCode").forEach(pre => {
                let html = pre.innerHTML

                if (!/¬§/.test(html)) {
                    // This code block is not a diff block
                    return
                }

                let matchingClosing = false
                while (/¬§/.test(html)) {
                    if (!matchingClosing) {
                        html = html.replace(/¬§/, "<span class='diff-area'>")
                    } else {
                        html = html.replace(/¬§/, "</span>")
                    }

                    matchingClosing = !matchingClosing
                }
                if (matchingClosing) {
                    console.error("unmatched diff block in source code", pre)
                    return
                }

                pre.innerHTML = html
                pre.classList.add("diff")
            })
        })
    </script>
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            function reflowGrids() {
                document.querySelectorAll(".grid.parent").forEach(parent => {
                    parent.classList.remove("column1")
                    let hasOverflow = false
                    for (child of parent.children) {
                        // We need to check grandchildren because of how overflow is set up for
                        // code elements
                        for (grandchild of child.children) {
                            // check for horizontal overflow
                            if (grandchild.scrollWidth > grandchild.clientWidth) {
                                hasOverflow = true
                                break
                            }
                        }
                        // Ugh, just give me labelled break
                        if (hasOverflow) {
                            break
                        }
                    }
                    if (hasOverflow) {
                        parent.classList.add("column1")
                    } else {
                        parent.classList.remove("column1")
                    }
                })
            }
            reflowGrids()
            window.addEventListener("resize", reflowGrids)
        })
    </script>

</head>

<body>
    <div class="underline-wrapper">
        <nav class="main-nav">
            <a href="/" class="site-title">welltypedwit.ch</a>
        </nav>
    </div>

    <article class="post">
        <h1 class="post-header">runST does not prevent resources from escaping</h1>
        <span class="date">31 December 2025</span>
        <p> A common pattern one might see in Haskell-adjacent
programming languages is the use of higher-rank types as a mechanism for
delimiting the scope in which certain values can be accessed, similar to
lifetimes or regions in other languages. This is sometimes called ‚Äúthe
<a
href="https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Control-Monad-ST.html#v:runST"><code>runST</code></a>
trick‚Äù, after its namesake</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ot">runST ::</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">ST</span> s a) <span class="ot">-&gt;</span> a </span></code></pre></div>
<p><code>runST</code> enables Haskell to use local mutation without
leaking any of the side effects to the outside. The higher-rank function
parameter ensures that this is safe, and references cannot be accessed
outside the call to <code>runST</code>.</p>
<p>‚Ä¶</p>
<p>You know what. It‚Äôs nearly 2026. Why am <em>I</em> explaining this
when you could ask an LLM.<a href="#fn1" class="footnote-ref"
id="fnref1" role="doc-noteref"><sup>1</sup></a> (This is ChatGPT. I‚Äôll
spare you the rambling)</p>
<p>
<div class='block'>
<div class='block-contents'>
<div class='block-contents-inline-code-wrapper'>
</p>
<h3 id="why-this-is-safe">üîê Why This Is Safe</h3>
<p>The <code>s</code> type parameter ensures referential
transparency:</p>
<p>Mutable references inside an <code>ST</code> block are tagged with
<code>s</code>.</p>
<p>Because <code>s</code> is universally quantified at the call site
(<code>forall s</code>), you cannot return an <code>STRef s ...</code>
out of runST.</p>
<p>This prevents mutation from leaking into the pure world.</p>
<p>So you can‚Äôt do this:</p>
<div class="sourceCode" id="cb2"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="ot">bad ::</span> <span class="dt">STRef</span> s <span class="dt">Int</span></span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>bad <span class="ot">=</span> runST (newSTRef <span class="dv">0</span>)</span></code></pre></div>
<p>The type system prevents it.</p>
<p>
</div>
</div>
</div>
</p>
<p>Okay, that <code>bad</code> snippet does indeed not compile! So
clearly this must be how <code>ST</code> works (and LLMs are always
correct anyway obviously).</p>
<p>Let‚Äôs play with this a little and, let‚Äôs say, write a safe wrapper
for <a
href="https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a>.</p>
<p><code>alloca</code> is unsafe because leaking the <code>Ptr</code>
and accessing it after the end of the continuation leads to
use-after-free.</p>
<p>If we add a type parameter to our pointer type and universally
quantify over it in <code>allocaSafe</code>, then ChatGPT told us that
the pointer cannot escape its continuation. So as long as we make sure
there is no way to get the underlying pointer back out, this should be
safe!<a href="#fn2" class="footnote-ref" id="fnref2"
role="doc-noteref"><sup>2</sup></a></p>
<div class="sourceCode" id="cb3"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co">-- abstract</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">SafePtr</span> s a <span class="ot">=</span> <span class="dt">MkSafePtr</span> (<span class="dt">Ptr</span> a)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a><span class="kw">type</span> role <span class="dt">SafePtr</span> nominal representational <span class="co">-- would you have thought of this? ^^</span></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a><span class="ot">peekSafe ::</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> <span class="dt">SafePtr</span> s a <span class="ot">-&gt;</span> <span class="dt">IO</span> a</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a>peekSafe (<span class="dt">MkSafePtr</span> pointer) <span class="ot">=</span> peek pointer</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1"></a><span class="ot">pokeSafe ::</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> <span class="dt">SafePtr</span> s a <span class="ot">-&gt;</span> a <span class="ot">-&gt;</span> <span class="dt">IO</span> ()</span>
<span id="cb3-9"><a href="#cb3-9" aria-hidden="true" tabindex="-1"></a>pokeSafe (<span class="dt">MkSafePtr</span> pointer) x <span class="ot">=</span> poke pointer x</span>
<span id="cb3-10"><a href="#cb3-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-11"><a href="#cb3-11" aria-hidden="true" tabindex="-1"></a><span class="ot">allocaSafe ::</span> <span class="dt">Storable</span> a <span class="ot">=&gt;</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">SafePtr</span> s a <span class="ot">-&gt;</span> <span class="dt">IO</span> b) <span class="ot">-&gt;</span> <span class="dt">IO</span> b</span>
<span id="cb3-12"><a href="#cb3-12" aria-hidden="true" tabindex="-1"></a>allocaSafe f <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb3-13"><a href="#cb3-13" aria-hidden="true" tabindex="-1"></a>   pointer <span class="ot">&lt;-</span> malloc</span>
<span id="cb3-14"><a href="#cb3-14" aria-hidden="true" tabindex="-1"></a>   result <span class="ot">&lt;-</span> f (<span class="dt">MkSafePtr</span> pointer)</span>
<span id="cb3-15"><a href="#cb3-15" aria-hidden="true" tabindex="-1"></a>   free pointer</span>
<span id="cb3-16"><a href="#cb3-16" aria-hidden="true" tabindex="-1"></a>   <span class="fu">pure</span> result</span></code></pre></div>
<p>If we try this, we can see that the following code <em>is</em>
rightfully rejected</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a>allocaSafe <span class="op">@</span><span class="dt">Int</span> \safePtr <span class="ot">-&gt;</span> <span class="fu">pure</span> safePtr</span></code></pre></div>
<p><strong></p>
<pre><code>allocasafe.hs:24:48: error: [GHC-46956]
    ‚Ä¢ Couldn&#39;t match expected type ‚Äòa0‚Äô
                  with actual type ‚ÄòSafePtr s Int‚Äô
        because type variable ‚Äòs‚Äô would escape its scope</code></pre>
<p></strong></p>
<p>So we‚Äôre safe, right?</p>
<h2 id="there-exists-a-problem">There exists a problem</h2>
<p>A seemingly quite unrelated feature of Haskell and many other
languages is called <em>existential types</em>. Whereas a
<em>universally</em> quantified type of the form
<code>forall a. ...</code> can be instantiated to use <em>any</em>
possible type for <code>a</code>, an existential type of the form
<code>exists a. ...</code> uses one specific type <code>a</code> but
doesn‚Äôt expose what it is (it only exposes that one such type
‚Äúexists‚Äù).</p>
<p>Haskell ‚Äî like most other languages ‚Äî doesn‚Äôt directly expose an
existential quantifier, but it still allows existentials in GADTs. For
example, this defines a type <code>SomeList</code> that contains a list
but doesn‚Äôt tell us what the type of its elements is.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">SomeList</span> <span class="kw">where</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">MkSomeList</span><span class="ot"> ::</span> [a] <span class="ot">-&gt;</span> <span class="dt">SomeList</span></span></code></pre></div>
<p>So, if we wrap <code>SafePtr</code> in an existential, we can hide
the <code>s</code> parameter we obtained from
<code>allocaSafe</code>!</p>
<div class="sourceCode" id="cb7"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="kw">data</span> <span class="dt">NotSoSafePtr</span> a <span class="kw">where</span></span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>   <span class="dt">MkNotSoSafePtr</span><span class="ot"> ::</span> <span class="dt">SafePtr</span> s a <span class="ot">-&gt;</span> <span class="dt">NotSoSafePtr</span> a</span></code></pre></div>
<p>Does this mean we can‚Ä¶</p>
<h2 id="use-after-free">Use-after-free</h2>
<div class="sourceCode" id="cb8"><pre class="sourceCode hs"><code class="sourceCode haskell"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkNotSoSafePtr</span> pointer <span class="ot">&lt;-</span> allocaSafe <span class="op">@</span><span class="dt">Int</span> \safePtr <span class="ot">-&gt;</span> <span class="fu">pure</span> (<span class="dt">MkNotSoSafePtr</span> safePtr)</span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>    pokeSafe pointer <span class="dv">42</span></span></code></pre></div>
<pre><code>$ valgrind safeptr
==230152== Memcheck, a memory error detector
[...]
==230569== Invalid write of size 8
==230569==    at 0x409C10: ghczminternal_GHCziInternalziForeignziStorable_zdfStorableInt1_info (in /home/prophet/temp/safeptr/safeptr)
==230569==  Address 0x4e69200 is 0 bytes inside a block of size 8 free&#39;d
==230569==    at 0x484C8EF: free (vg_replace_malloc.c:989)
==230569==    by 0x409811: ghczminternal_GHCziInternalziForeignziMarshalziAlloc_free1_info (in /home/prophet/temp/safeptr/safeptr)
==230569==  Block was alloc&#39;d at
==230569==    at 0x48497A8: malloc (vg_replace_malloc.c:446)
==230569==    by 0x40974E: ghczminternal_GHCziInternalziForeignziMarshalziAlloc_malloc_info (in /home/prophet/temp/safeptr/safeptr)</code></pre>
<h2 id="so-how-does-st-actually-work">So how does <code>ST</code>
<em>actually</em> work?</h2>
<p>The guarantee <code>ST</code> gives is that an <code>STRef</code> (or
similar) can only be read from or written to <em>in the same
<code>runST</code> invocation that created it</em>.</p>
<p>The higher-rank continuation doesn‚Äôt directly contribute to this
safety guarantee at all. It only creates a fresh type-level <em>tag</em>
that uniquely identifies the <code>runST</code> invocation and links the
<code>STRef</code> to it.</p>
<p>Leaking the <code>STRef</code> (or any other resource tagged this
way) is absolutely possible. It just cannot be <em>accessed</em> after
the leakage because any other <code>runST</code> call will use an
<code>ST</code> monad with a different <code>s</code> variable.</p>
<h2 id="bonus-we-dont-even-need-existentials">Bonus: We don‚Äôt even need
existentials</h2>
<p>Using regular higher-rank types, we can encode an existential type
like <code>exists s. T s</code> as a rank-2 function
<code>forall r. (forall s. T s -&gt; r) -&gt; r</code>.</p>
<p>And that‚Äôs still enough for a use-after-free!</p>
<div class="sourceCode" id="cb10"><pre
class="sourceCode hs"><code class="sourceCode haskell"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="kw">newtype</span> <span class="dt">NotSoSafePtr</span> a <span class="ot">=</span> <span class="dt">MkNotSoSafePtr</span> (<span class="kw">forall</span> r<span class="op">.</span> (<span class="kw">forall</span> s<span class="op">.</span> <span class="dt">SafePtr</span> s a <span class="ot">-&gt;</span> r) <span class="ot">-&gt;</span> r)</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a><span class="ot">main ::</span> <span class="dt">IO</span> ()</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>main <span class="ot">=</span> <span class="kw">do</span></span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a>    <span class="dt">MkNotSoSafePtr</span> usePtr <span class="ot">&lt;-</span> allocaSafe <span class="op">@</span><span class="dt">Int</span> \safePtr <span class="ot">-&gt;</span> <span class="fu">pure</span> (<span class="dt">MkNotSoSafePtr</span> \f <span class="ot">-&gt;</span> f safePtr)</span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>    usePtr \pointer <span class="ot">-&gt;</span> pokeSafe pointer <span class="dv">42</span>    </span></code></pre></div>
<section id="footnotes" class="footnotes footnotes-end-of-document"
role="doc-endnotes">
<hr />
<ol>
<li id="fn1"><p>A bit more seriously: I think this works as a decent
proxy for what the average haskeller thinks. At a minimum, its
explanation lines up with what I used to believe.<a href="#fnref1"
class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
<li id="fn2"><p>If you‚Äôre wondering why I‚Äôm defining
<code>allocaSafe</code> in terms of <a
href="https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Foreign-Marshal-Alloc.html#v:malloc"><code>malloc</code></a>
and <a
href="https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Foreign-Marshal-Alloc.html#v:free"><code>free</code></a>
instead of <a
href="https://hackage-content.haskell.org/package/base-4.22.0.0/docs/Foreign-Marshal-Alloc.html#v:alloca"><code>alloca</code></a>,
it‚Äôs because <code>alloca</code> actually doesn‚Äôt use
<code>malloc</code>! It <a
href="https://hackage-content.haskell.org/package/ghc-internal-9.1401.0/docs/src/GHC.Internal.Foreign.Marshal.Alloc.html#allocaBytesAlignedAndUnchecked">allocates
a byte array on the garbage collected heap and then takes an unmanaged
pointer to its contents</a> because that‚Äôs faster than actually going
through <code>malloc</code> and <code>free</code>. So if we leaked the
pointer out of <code>alloca</code>, there would still be a risk of
use-after-free but it would only trigger after a garbage collection and
wouldn‚Äôt be on the C heap so it would be hard to detect.<a
href="#fnref2" class="footnote-back" role="doc-backlink">‚Ü©Ô∏é</a></p></li>
</ol>
</section>
    </article>
</body>

</html>